/*
 * Teamwork.com Projects API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 3.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package projv3

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// BudgetsApiService BudgetsApi service
type BudgetsApiService service

type ApiDELETEProjectsApiV3BudgetNotificationsnotificationIdJsonRequest struct {
	ctx _context.Context
	ApiService *BudgetsApiService
	notificationId int32
}


func (r ApiDELETEProjectsApiV3BudgetNotificationsnotificationIdJsonRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DELETEProjectsApiV3BudgetNotificationsnotificationIdJsonExecute(r)
}

/*
 * DELETEProjectsApiV3BudgetNotificationsnotificationIdJson Delete an existing notification.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param notificationId
 * @return ApiDELETEProjectsApiV3BudgetNotificationsnotificationIdJsonRequest
 */
func (a *BudgetsApiService) DELETEProjectsApiV3BudgetNotificationsnotificationIdJson(ctx _context.Context, notificationId int32) ApiDELETEProjectsApiV3BudgetNotificationsnotificationIdJsonRequest {
	return ApiDELETEProjectsApiV3BudgetNotificationsnotificationIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		notificationId: notificationId,
	}
}

/*
 * Execute executes the request
 */
func (a *BudgetsApiService) DELETEProjectsApiV3BudgetNotificationsnotificationIdJsonExecute(r ApiDELETEProjectsApiV3BudgetNotificationsnotificationIdJsonRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.DELETEProjectsApiV3BudgetNotificationsnotificationIdJson")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/budget/notifications/{notificationId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"notificationId"+"}", _neturl.PathEscape(parameterToString(r.notificationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDELETEProjectsApiV3BudgetsidJsonRequest struct {
	ctx _context.Context
	ApiService *BudgetsApiService
	id int32
}


func (r ApiDELETEProjectsApiV3BudgetsidJsonRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DELETEProjectsApiV3BudgetsidJsonExecute(r)
}

/*
 * DELETEProjectsApiV3BudgetsidJson Delete an existing budget.
 * Delete the budget with the provided budget id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiDELETEProjectsApiV3BudgetsidJsonRequest
 */
func (a *BudgetsApiService) DELETEProjectsApiV3BudgetsidJson(ctx _context.Context, id int32) ApiDELETEProjectsApiV3BudgetsidJsonRequest {
	return ApiDELETEProjectsApiV3BudgetsidJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *BudgetsApiService) DELETEProjectsApiV3BudgetsidJsonExecute(r ApiDELETEProjectsApiV3BudgetsidJsonRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.DELETEProjectsApiV3BudgetsidJson")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/budgets/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3BudgetsJsonRequest struct {
	ctx _context.Context
	ApiService *BudgetsApiService
	updatedAfterDate *time.Time
	updatedAfter *time.Time
	type_ *string
	status *string
	projectStatuses *string
	orderMode *string
	orderBy *string
	projectHealths *int32
	pageSize *int32
	page *int32
	showDeleted *bool
	showArchived *bool
	onlyStarredProjects *bool
	onlyArchived *bool
	matchAllProjectTags *bool
	includeArchivedProjects *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
	include *[]string
	ids *[]int32
	fieldsUsers *[]string
	fieldsTeams *[]string
	fieldsProjects *[]string
	fieldsProjectBudgetNotifications *[]string
	fieldsCompanies *[]string
}

func (r ApiGETProjectsApiV3BudgetsJsonRequest) UpdatedAfterDate(updatedAfterDate time.Time) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.updatedAfterDate = &updatedAfterDate
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) Type_(type_ string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.type_ = &type_
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) Status(status string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.status = &status
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) OrderMode(orderMode string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) OrderBy(orderBy string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) PageSize(pageSize int32) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) Page(page int32) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) ShowDeleted(showDeleted bool) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.showDeleted = &showDeleted
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) ShowArchived(showArchived bool) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.showArchived = &showArchived
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) OnlyArchived(onlyArchived bool) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.onlyArchived = &onlyArchived
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) Include(include []string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) Ids(ids []int32) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.ids = &ids
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) FieldsTeams(fieldsTeams []string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.fieldsTeams = &fieldsTeams
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) FieldsProjectBudgetNotifications(fieldsProjectBudgetNotifications []string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.fieldsProjectBudgetNotifications = &fieldsProjectBudgetNotifications
	return r
}
func (r ApiGETProjectsApiV3BudgetsJsonRequest) FieldsCompanies(fieldsCompanies []string) ApiGETProjectsApiV3BudgetsJsonRequest {
	r.fieldsCompanies = &fieldsCompanies
	return r
}

func (r ApiGETProjectsApiV3BudgetsJsonRequest) Execute() (BudgetProjectBudgetsResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3BudgetsJsonExecute(r)
}

/*
 * GETProjectsApiV3BudgetsJson Get all budgets.
 * Get a list of budgets information.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3BudgetsJsonRequest
 */
func (a *BudgetsApiService) GETProjectsApiV3BudgetsJson(ctx _context.Context) ApiGETProjectsApiV3BudgetsJsonRequest {
	return ApiGETProjectsApiV3BudgetsJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return BudgetProjectBudgetsResponse
 */
func (a *BudgetsApiService) GETProjectsApiV3BudgetsJsonExecute(r ApiGETProjectsApiV3BudgetsJsonRequest) (BudgetProjectBudgetsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetProjectBudgetsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.GETProjectsApiV3BudgetsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/budgets.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.updatedAfterDate != nil {
		localVarQueryParams.Add("updatedAfterDate", parameterToString(*r.updatedAfterDate, ""))
	}
	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.showDeleted != nil {
		localVarQueryParams.Add("showDeleted", parameterToString(*r.showDeleted, ""))
	}
	if r.showArchived != nil {
		localVarQueryParams.Add("showArchived", parameterToString(*r.showArchived, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.onlyArchived != nil {
		localVarQueryParams.Add("onlyArchived", parameterToString(*r.onlyArchived, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsTeams != nil {
		localVarQueryParams.Add("fields[teams]", parameterToString(*r.fieldsTeams, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsProjectBudgetNotifications != nil {
		localVarQueryParams.Add("fields[projectBudgetNotifications]", parameterToString(*r.fieldsProjectBudgetNotifications, "csv"))
	}
	if r.fieldsCompanies != nil {
		localVarQueryParams.Add("fields[companies]", parameterToString(*r.fieldsCompanies, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3BudgetsidJsonRequest struct {
	ctx _context.Context
	ApiService *BudgetsApiService
	id int32
}


func (r ApiGETProjectsApiV3BudgetsidJsonRequest) Execute() (BudgetResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3BudgetsidJsonExecute(r)
}

/*
 * GETProjectsApiV3BudgetsidJson Get a specific budget.
 * Gets the budget information for the provided budget id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETProjectsApiV3BudgetsidJsonRequest
 */
func (a *BudgetsApiService) GETProjectsApiV3BudgetsidJson(ctx _context.Context, id int32) ApiGETProjectsApiV3BudgetsidJsonRequest {
	return ApiGETProjectsApiV3BudgetsidJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BudgetResponse
 */
func (a *BudgetsApiService) GETProjectsApiV3BudgetsidJsonExecute(r ApiGETProjectsApiV3BudgetsidJsonRequest) (BudgetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.GETProjectsApiV3BudgetsidJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/budgets/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3BudgetsidUsagesJsonRequest struct {
	ctx _context.Context
	ApiService *BudgetsApiService
	id int32
}


func (r ApiGETProjectsApiV3BudgetsidUsagesJsonRequest) Execute() (BudgetProjectBudgetUsageResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3BudgetsidUsagesJsonExecute(r)
}

/*
 * GETProjectsApiV3BudgetsidUsagesJson Get daily budget capacity used.
 * Gets the budget used capacity for the provided budget id,
with the daily timeline of capacity usage.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETProjectsApiV3BudgetsidUsagesJsonRequest
 */
func (a *BudgetsApiService) GETProjectsApiV3BudgetsidUsagesJson(ctx _context.Context, id int32) ApiGETProjectsApiV3BudgetsidUsagesJsonRequest {
	return ApiGETProjectsApiV3BudgetsidUsagesJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BudgetProjectBudgetUsageResponse
 */
func (a *BudgetsApiService) GETProjectsApiV3BudgetsidUsagesJsonExecute(r ApiGETProjectsApiV3BudgetsidUsagesJsonRequest) (BudgetProjectBudgetUsageResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetProjectBudgetUsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.GETProjectsApiV3BudgetsidUsagesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/budgets/{id}/usages.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsBudgetsUsagesJsonRequest struct {
	ctx _context.Context
	ApiService *BudgetsApiService
}


func (r ApiGETProjectsApiV3ProjectsBudgetsUsagesJsonRequest) Execute() (BudgetProjectBudgetsUsagesResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsBudgetsUsagesJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsBudgetsUsagesJson Get the budgets usages for a set of projects
 * Gets the budget used capacity for a set of projects,
with the daily timeline of capacity usage.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsBudgetsUsagesJsonRequest
 */
func (a *BudgetsApiService) GETProjectsApiV3ProjectsBudgetsUsagesJson(ctx _context.Context) ApiGETProjectsApiV3ProjectsBudgetsUsagesJsonRequest {
	return ApiGETProjectsApiV3ProjectsBudgetsUsagesJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return BudgetProjectBudgetsUsagesResponse
 */
func (a *BudgetsApiService) GETProjectsApiV3ProjectsBudgetsUsagesJsonExecute(r ApiGETProjectsApiV3ProjectsBudgetsUsagesJsonRequest) (BudgetProjectBudgetsUsagesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetProjectBudgetsUsagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.GETProjectsApiV3ProjectsBudgetsUsagesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/budgets/usages.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPATCHProjectsApiV3BudgetNotificationsnotificationIdJsonRequest struct {
	ctx _context.Context
	ApiService *BudgetsApiService
	notificationId int32
	notificationRequest *NotificationRequest
}

func (r ApiPATCHProjectsApiV3BudgetNotificationsnotificationIdJsonRequest) NotificationRequest(notificationRequest NotificationRequest) ApiPATCHProjectsApiV3BudgetNotificationsnotificationIdJsonRequest {
	r.notificationRequest = &notificationRequest
	return r
}

func (r ApiPATCHProjectsApiV3BudgetNotificationsnotificationIdJsonRequest) Execute() (NotificationResponse, *_nethttp.Response, error) {
	return r.ApiService.PATCHProjectsApiV3BudgetNotificationsnotificationIdJsonExecute(r)
}

/*
 * PATCHProjectsApiV3BudgetNotificationsnotificationIdJson Update an existing notification.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param notificationId
 * @return ApiPATCHProjectsApiV3BudgetNotificationsnotificationIdJsonRequest
 */
func (a *BudgetsApiService) PATCHProjectsApiV3BudgetNotificationsnotificationIdJson(ctx _context.Context, notificationId int32) ApiPATCHProjectsApiV3BudgetNotificationsnotificationIdJsonRequest {
	return ApiPATCHProjectsApiV3BudgetNotificationsnotificationIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		notificationId: notificationId,
	}
}

/*
 * Execute executes the request
 * @return NotificationResponse
 */
func (a *BudgetsApiService) PATCHProjectsApiV3BudgetNotificationsnotificationIdJsonExecute(r ApiPATCHProjectsApiV3BudgetNotificationsnotificationIdJsonRequest) (NotificationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NotificationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.PATCHProjectsApiV3BudgetNotificationsnotificationIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/budget/notifications/{notificationId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"notificationId"+"}", _neturl.PathEscape(parameterToString(r.notificationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.notificationRequest == nil {
		return localVarReturnValue, nil, reportError("notificationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPATCHProjectsApiV3BudgetsidJsonRequest struct {
	ctx _context.Context
	ApiService *BudgetsApiService
	id int32
	budgetRequest *BudgetRequest
}

func (r ApiPATCHProjectsApiV3BudgetsidJsonRequest) BudgetRequest(budgetRequest BudgetRequest) ApiPATCHProjectsApiV3BudgetsidJsonRequest {
	r.budgetRequest = &budgetRequest
	return r
}

func (r ApiPATCHProjectsApiV3BudgetsidJsonRequest) Execute() (BudgetResponse, *_nethttp.Response, error) {
	return r.ApiService.PATCHProjectsApiV3BudgetsidJsonExecute(r)
}

/*
 * PATCHProjectsApiV3BudgetsidJson Update an existing budget.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPATCHProjectsApiV3BudgetsidJsonRequest
 */
func (a *BudgetsApiService) PATCHProjectsApiV3BudgetsidJson(ctx _context.Context, id int32) ApiPATCHProjectsApiV3BudgetsidJsonRequest {
	return ApiPATCHProjectsApiV3BudgetsidJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return BudgetResponse
 */
func (a *BudgetsApiService) PATCHProjectsApiV3BudgetsidJsonExecute(r ApiPATCHProjectsApiV3BudgetsidJsonRequest) (BudgetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.PATCHProjectsApiV3BudgetsidJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/budgets/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.budgetRequest == nil {
		return localVarReturnValue, nil, reportError("budgetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.budgetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTProjectsApiV3BudgetsBulkDeleteJsonRequest struct {
	ctx _context.Context
	ApiService *BudgetsApiService
	budgetBulkDeleteRequest *BudgetBulkDeleteRequest
}

func (r ApiPOSTProjectsApiV3BudgetsBulkDeleteJsonRequest) BudgetBulkDeleteRequest(budgetBulkDeleteRequest BudgetBulkDeleteRequest) ApiPOSTProjectsApiV3BudgetsBulkDeleteJsonRequest {
	r.budgetBulkDeleteRequest = &budgetBulkDeleteRequest
	return r
}

func (r ApiPOSTProjectsApiV3BudgetsBulkDeleteJsonRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.POSTProjectsApiV3BudgetsBulkDeleteJsonExecute(r)
}

/*
 * POSTProjectsApiV3BudgetsBulkDeleteJson Delete many budgets at once.
 * Delete several budgets in a bulk.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPOSTProjectsApiV3BudgetsBulkDeleteJsonRequest
 */
func (a *BudgetsApiService) POSTProjectsApiV3BudgetsBulkDeleteJson(ctx _context.Context) ApiPOSTProjectsApiV3BudgetsBulkDeleteJsonRequest {
	return ApiPOSTProjectsApiV3BudgetsBulkDeleteJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *BudgetsApiService) POSTProjectsApiV3BudgetsBulkDeleteJsonExecute(r ApiPOSTProjectsApiV3BudgetsBulkDeleteJsonRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.POSTProjectsApiV3BudgetsBulkDeleteJson")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/budgets/bulk/delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.budgetBulkDeleteRequest == nil {
		return nil, reportError("budgetBulkDeleteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.budgetBulkDeleteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPOSTProjectsApiV3BudgetsJsonRequest struct {
	ctx _context.Context
	ApiService *BudgetsApiService
	budgetRequest *BudgetRequest
}

func (r ApiPOSTProjectsApiV3BudgetsJsonRequest) BudgetRequest(budgetRequest BudgetRequest) ApiPOSTProjectsApiV3BudgetsJsonRequest {
	r.budgetRequest = &budgetRequest
	return r
}

func (r ApiPOSTProjectsApiV3BudgetsJsonRequest) Execute() (BudgetResponse, *_nethttp.Response, error) {
	return r.ApiService.POSTProjectsApiV3BudgetsJsonExecute(r)
}

/*
 * POSTProjectsApiV3BudgetsJson Create a new budget.
 * Creates a new budget.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPOSTProjectsApiV3BudgetsJsonRequest
 */
func (a *BudgetsApiService) POSTProjectsApiV3BudgetsJson(ctx _context.Context) ApiPOSTProjectsApiV3BudgetsJsonRequest {
	return ApiPOSTProjectsApiV3BudgetsJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return BudgetResponse
 */
func (a *BudgetsApiService) POSTProjectsApiV3BudgetsJsonExecute(r ApiPOSTProjectsApiV3BudgetsJsonRequest) (BudgetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BudgetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetsApiService.POSTProjectsApiV3BudgetsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/budgets.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.budgetRequest == nil {
		return localVarReturnValue, nil, reportError("budgetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.budgetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
