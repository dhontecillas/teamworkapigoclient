/*
 * Teamwork Projects API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pmv1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ReactionsV2ApiService ReactionsV2Api service
type ReactionsV2ApiService service

type ApiGETCommentsCommentIdReactionsJsonRequest struct {
	ctx _context.Context
	ApiService *ReactionsV2ApiService
	commentId string
	reactionType *string
}

func (r ApiGETCommentsCommentIdReactionsJsonRequest) ReactionType(reactionType string) ApiGETCommentsCommentIdReactionsJsonRequest {
	r.reactionType = &reactionType
	return r
}

func (r ApiGETCommentsCommentIdReactionsJsonRequest) Execute() (InlineResponse2009, *_nethttp.Response, error) {
	return r.ApiService.GETCommentsCommentIdReactionsJsonExecute(r)
}

/*
 * GETCommentsCommentIdReactionsJson Get Reactions on a specific Comment
 * **NOTE: This is a V2 endpoint. These endpoints can be used but are subject to change.**

Reactions are only available to users who have the new dashboard enabled via the beta program. In order to do use reactions you need to first enable this.


Returns all reactions on the given comment.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param commentId
 * @return ApiGETCommentsCommentIdReactionsJsonRequest
 */
func (a *ReactionsV2ApiService) GETCommentsCommentIdReactionsJson(ctx _context.Context, commentId string) ApiGETCommentsCommentIdReactionsJsonRequest {
	return ApiGETCommentsCommentIdReactionsJsonRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2009
 */
func (a *ReactionsV2ApiService) GETCommentsCommentIdReactionsJsonExecute(r ApiGETCommentsCommentIdReactionsJsonRequest) (InlineResponse2009, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2009
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsV2ApiService.GETCommentsCommentIdReactionsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{commentId}/reactions.json"
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", _neturl.PathEscape(parameterToString(r.commentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.reactionType == nil {
		return localVarReturnValue, nil, reportError("reactionType is required and must be specified")
	}

	localVarQueryParams.Add("reactionType", parameterToString(*r.reactionType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsProjectIdUpdateJsonRequest struct {
	ctx _context.Context
	ApiService *ReactionsV2ApiService
	projectId string
	getReactions *string
	body *InlineObject80
}

func (r ApiGETProjectsProjectIdUpdateJsonRequest) GetReactions(getReactions string) ApiGETProjectsProjectIdUpdateJsonRequest {
	r.getReactions = &getReactions
	return r
}
func (r ApiGETProjectsProjectIdUpdateJsonRequest) Body(body InlineObject80) ApiGETProjectsProjectIdUpdateJsonRequest {
	r.body = &body
	return r
}

func (r ApiGETProjectsProjectIdUpdateJsonRequest) Execute() (InlineResponse20080, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsProjectIdUpdateJsonExecute(r)
}

/*
 * GETProjectsProjectIdUpdateJson Get Reactions to a Project Update
 * **NOTE: This is a V2 endpoint. These endpoints can be used but are subject to change.**

Reactions are only available to users who have the new dashboard enabled via the beta program. In order to do use reactions you need to first enable this.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId
 * @return ApiGETProjectsProjectIdUpdateJsonRequest
 */
func (a *ReactionsV2ApiService) GETProjectsProjectIdUpdateJson(ctx _context.Context, projectId string) ApiGETProjectsProjectIdUpdateJsonRequest {
	return ApiGETProjectsProjectIdUpdateJsonRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20080
 */
func (a *ReactionsV2ApiService) GETProjectsProjectIdUpdateJsonExecute(r ApiGETProjectsProjectIdUpdateJsonRequest) (InlineResponse20080, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20080
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsV2ApiService.GETProjectsProjectIdUpdateJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{projectId}/update.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.getReactions == nil {
		return localVarReturnValue, nil, reportError("getReactions is required and must be specified")
	}

	localVarQueryParams.Add("getReactions", parameterToString(*r.getReactions, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETV2MessagesMessageIdJsonRequest struct {
	ctx _context.Context
	ApiService *ReactionsV2ApiService
	messageId string
	getReactions *bool
}

func (r ApiGETV2MessagesMessageIdJsonRequest) GetReactions(getReactions bool) ApiGETV2MessagesMessageIdJsonRequest {
	r.getReactions = &getReactions
	return r
}

func (r ApiGETV2MessagesMessageIdJsonRequest) Execute() (InlineResponse200115, *_nethttp.Response, error) {
	return r.ApiService.GETV2MessagesMessageIdJsonExecute(r)
}

/*
 * GETV2MessagesMessageIdJson Get Reactions to a Message
 * **NOTE: This is a V2 endpoint. These endpoints can be used but are subject to change.**

This is on the comments api, in order to turn the reactions you <b>must add</b> getReactions=true.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param messageId
 * @return ApiGETV2MessagesMessageIdJsonRequest
 */
func (a *ReactionsV2ApiService) GETV2MessagesMessageIdJson(ctx _context.Context, messageId string) ApiGETV2MessagesMessageIdJsonRequest {
	return ApiGETV2MessagesMessageIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200115
 */
func (a *ReactionsV2ApiService) GETV2MessagesMessageIdJsonExecute(r ApiGETV2MessagesMessageIdJsonRequest) (InlineResponse200115, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200115
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsV2ApiService.GETV2MessagesMessageIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v/2/messages/{messageId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.getReactions == nil {
		return localVarReturnValue, nil, reportError("getReactions is required and must be specified")
	}

	localVarQueryParams.Add("getReactions", parameterToString(*r.getReactions, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETV2MessagesMessageIdRepliesJsonRequest struct {
	ctx _context.Context
	ApiService *ReactionsV2ApiService
	messageId string
	getReactions *bool
}

func (r ApiGETV2MessagesMessageIdRepliesJsonRequest) GetReactions(getReactions bool) ApiGETV2MessagesMessageIdRepliesJsonRequest {
	r.getReactions = &getReactions
	return r
}

func (r ApiGETV2MessagesMessageIdRepliesJsonRequest) Execute() (InlineResponse200116, *_nethttp.Response, error) {
	return r.ApiService.GETV2MessagesMessageIdRepliesJsonExecute(r)
}

/*
 * GETV2MessagesMessageIdRepliesJson Get Reactions on Message Replies
 * **NOTE: This is a V2 endpoint. These endpoints can be used but are subject to change.**

Reactions are only available to users who have the new dashboard enabled via the beta program. In order to do use reactions you need to first enable this.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param messageId
 * @return ApiGETV2MessagesMessageIdRepliesJsonRequest
 */
func (a *ReactionsV2ApiService) GETV2MessagesMessageIdRepliesJson(ctx _context.Context, messageId string) ApiGETV2MessagesMessageIdRepliesJsonRequest {
	return ApiGETV2MessagesMessageIdRepliesJsonRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200116
 */
func (a *ReactionsV2ApiService) GETV2MessagesMessageIdRepliesJsonExecute(r ApiGETV2MessagesMessageIdRepliesJsonRequest) (InlineResponse200116, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200116
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsV2ApiService.GETV2MessagesMessageIdRepliesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v/2/messages/{messageId}/replies.json"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.getReactions != nil {
		localVarQueryParams.Add("getReactions", parameterToString(*r.getReactions, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETV2TasksIdCommentsJsonRequest struct {
	ctx _context.Context
	ApiService *ReactionsV2ApiService
	id string
	getReactions *string
	page *float32
	pageSize *string
	getLikes *string
	getEmoji *string
	orderBy *string
	sortOrder *string
}

func (r ApiGETV2TasksIdCommentsJsonRequest) GetReactions(getReactions string) ApiGETV2TasksIdCommentsJsonRequest {
	r.getReactions = &getReactions
	return r
}
func (r ApiGETV2TasksIdCommentsJsonRequest) Page(page float32) ApiGETV2TasksIdCommentsJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETV2TasksIdCommentsJsonRequest) PageSize(pageSize string) ApiGETV2TasksIdCommentsJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETV2TasksIdCommentsJsonRequest) GetLikes(getLikes string) ApiGETV2TasksIdCommentsJsonRequest {
	r.getLikes = &getLikes
	return r
}
func (r ApiGETV2TasksIdCommentsJsonRequest) GetEmoji(getEmoji string) ApiGETV2TasksIdCommentsJsonRequest {
	r.getEmoji = &getEmoji
	return r
}
func (r ApiGETV2TasksIdCommentsJsonRequest) OrderBy(orderBy string) ApiGETV2TasksIdCommentsJsonRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETV2TasksIdCommentsJsonRequest) SortOrder(sortOrder string) ApiGETV2TasksIdCommentsJsonRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGETV2TasksIdCommentsJsonRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GETV2TasksIdCommentsJsonExecute(r)
}

/*
 * GETV2TasksIdCommentsJson Get Comment Reactions on a task
 * **NOTE: This is a V2 endpoint. These endpoints can be used but are subject to change.**

This is on the comments api, in order to turn the reactions you <b>must add</b> getReactions=true.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETV2TasksIdCommentsJsonRequest
 */
func (a *ReactionsV2ApiService) GETV2TasksIdCommentsJson(ctx _context.Context, id string) ApiGETV2TasksIdCommentsJsonRequest {
	return ApiGETV2TasksIdCommentsJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *ReactionsV2ApiService) GETV2TasksIdCommentsJsonExecute(r ApiGETV2TasksIdCommentsJsonRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsV2ApiService.GETV2TasksIdCommentsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v/2/tasks/{id}/comments.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.getReactions == nil {
		return localVarReturnValue, nil, reportError("getReactions is required and must be specified")
	}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.getLikes != nil {
		localVarQueryParams.Add("getLikes", parameterToString(*r.getLikes, ""))
	}
	if r.getEmoji != nil {
		localVarQueryParams.Add("getEmoji", parameterToString(*r.getEmoji, ""))
	}
	localVarQueryParams.Add("getReactions", parameterToString(*r.getReactions, ""))
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTCommentsCommentIdReactJsonRequest struct {
	ctx _context.Context
	ApiService *ReactionsV2ApiService
	commentId string
}


func (r ApiPUTCommentsCommentIdReactJsonRequest) Execute() (InlineResponse2008, *_nethttp.Response, error) {
	return r.ApiService.PUTCommentsCommentIdReactJsonExecute(r)
}

/*
 * PUTCommentsCommentIdReactJson React to a Comment
 * **NOTE: This is a V2 endpoint. These endpoints can be used but are subject to change.**

Reactions are only available to users who have the new dashboard enabled via the beta program. In order to do use reactions you need to first enable this.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param commentId
 * @return ApiPUTCommentsCommentIdReactJsonRequest
 */
func (a *ReactionsV2ApiService) PUTCommentsCommentIdReactJson(ctx _context.Context, commentId string) ApiPUTCommentsCommentIdReactJsonRequest {
	return ApiPUTCommentsCommentIdReactJsonRequest{
		ApiService: a,
		ctx: ctx,
		commentId: commentId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2008
 */
func (a *ReactionsV2ApiService) PUTCommentsCommentIdReactJsonExecute(r ApiPUTCommentsCommentIdReactJsonRequest) (InlineResponse2008, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsV2ApiService.PUTCommentsCommentIdReactJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/comments/{commentId}/react.json"
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", _neturl.PathEscape(parameterToString(r.commentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTMessagerepliesMessageIdReactJsonRequest struct {
	ctx _context.Context
	ApiService *ReactionsV2ApiService
	messageId string
	body *InlineObject28
}

func (r ApiPUTMessagerepliesMessageIdReactJsonRequest) Body(body InlineObject28) ApiPUTMessagerepliesMessageIdReactJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTMessagerepliesMessageIdReactJsonRequest) Execute() (InlineResponse2008, *_nethttp.Response, error) {
	return r.ApiService.PUTMessagerepliesMessageIdReactJsonExecute(r)
}

/*
 * PUTMessagerepliesMessageIdReactJson React to a Message
 * **NOTE: This is a V2 endpoint. These endpoints can be used but are subject to change.**

This is on the comments api, in order to turn the reactions you <b>must add</b> getReactions=true.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param messageId
 * @return ApiPUTMessagerepliesMessageIdReactJsonRequest
 */
func (a *ReactionsV2ApiService) PUTMessagerepliesMessageIdReactJson(ctx _context.Context, messageId string) ApiPUTMessagerepliesMessageIdReactJsonRequest {
	return ApiPUTMessagerepliesMessageIdReactJsonRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2008
 */
func (a *ReactionsV2ApiService) PUTMessagerepliesMessageIdReactJsonExecute(r ApiPUTMessagerepliesMessageIdReactJsonRequest) (InlineResponse2008, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsV2ApiService.PUTMessagerepliesMessageIdReactJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messagereplies/{messageId}/react.json"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTMessagerepliesMessagereplyIdReactJsonRequest struct {
	ctx _context.Context
	ApiService *ReactionsV2ApiService
	messagereplyId string
	body *InlineObject29
}

func (r ApiPUTMessagerepliesMessagereplyIdReactJsonRequest) Body(body InlineObject29) ApiPUTMessagerepliesMessagereplyIdReactJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTMessagerepliesMessagereplyIdReactJsonRequest) Execute() (InlineResponse2008, *_nethttp.Response, error) {
	return r.ApiService.PUTMessagerepliesMessagereplyIdReactJsonExecute(r)
}

/*
 * PUTMessagerepliesMessagereplyIdReactJson React to a Message Reply
 * **NOTE: This is a V2 endpoint. These endpoints can be used but are subject to change.**

Reactions are only available to users who have the new dashboard enabled via the beta program. In order to do use reactions you need to first enable this.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param messagereplyId
 * @return ApiPUTMessagerepliesMessagereplyIdReactJsonRequest
 */
func (a *ReactionsV2ApiService) PUTMessagerepliesMessagereplyIdReactJson(ctx _context.Context, messagereplyId string) ApiPUTMessagerepliesMessagereplyIdReactJsonRequest {
	return ApiPUTMessagerepliesMessagereplyIdReactJsonRequest{
		ApiService: a,
		ctx: ctx,
		messagereplyId: messagereplyId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2008
 */
func (a *ReactionsV2ApiService) PUTMessagerepliesMessagereplyIdReactJsonExecute(r ApiPUTMessagerepliesMessagereplyIdReactJsonRequest) (InlineResponse2008, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsV2ApiService.PUTMessagerepliesMessagereplyIdReactJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messagereplies/{messagereplyId}/react.json"
	localVarPath = strings.Replace(localVarPath, "{"+"messagereplyId"+"}", _neturl.PathEscape(parameterToString(r.messagereplyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTProjectsUpdatesUpdateIdReactJsonRequest struct {
	ctx _context.Context
	ApiService *ReactionsV2ApiService
	updateId string
	body *InlineObject54
}

func (r ApiPUTProjectsUpdatesUpdateIdReactJsonRequest) Body(body InlineObject54) ApiPUTProjectsUpdatesUpdateIdReactJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTProjectsUpdatesUpdateIdReactJsonRequest) Execute() (InlineResponse2008, *_nethttp.Response, error) {
	return r.ApiService.PUTProjectsUpdatesUpdateIdReactJsonExecute(r)
}

/*
 * PUTProjectsUpdatesUpdateIdReactJson React to a Project Update
 * **NOTE: This is a V2 endpoint. These endpoints can be used but are subject to change.**

Reactions are only available to users who have the new dashboard enabled via the beta program. In order to do use reactions you need to first enable this.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param updateId
 * @return ApiPUTProjectsUpdatesUpdateIdReactJsonRequest
 */
func (a *ReactionsV2ApiService) PUTProjectsUpdatesUpdateIdReactJson(ctx _context.Context, updateId string) ApiPUTProjectsUpdatesUpdateIdReactJsonRequest {
	return ApiPUTProjectsUpdatesUpdateIdReactJsonRequest{
		ApiService: a,
		ctx: ctx,
		updateId: updateId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2008
 */
func (a *ReactionsV2ApiService) PUTProjectsUpdatesUpdateIdReactJsonExecute(r ApiPUTProjectsUpdatesUpdateIdReactJsonRequest) (InlineResponse2008, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsV2ApiService.PUTProjectsUpdatesUpdateIdReactJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/updates/{updateId}/react.json"
	localVarPath = strings.Replace(localVarPath, "{"+"updateId"+"}", _neturl.PathEscape(parameterToString(r.updateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTResourceIdUnreactJsonRequest struct {
	ctx _context.Context
	ApiService *ReactionsV2ApiService
	id string
	body *InlineObject82
}

func (r ApiPUTResourceIdUnreactJsonRequest) Body(body InlineObject82) ApiPUTResourceIdUnreactJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTResourceIdUnreactJsonRequest) Execute() (InlineResponse20085, *_nethttp.Response, error) {
	return r.ApiService.PUTResourceIdUnreactJsonExecute(r)
}

/*
 * PUTResourceIdUnreactJson Unreacting to a Comment/Message/ProjectUpdate
 * **NOTE: This is a V2 endpoint. These endpoints can be used but are subject to change.**

This is on the comments api, in order to turn the reactions you <b>must add</b> getReactions=true.


Unreact works the same as the react endpoints but you are unreacting rather than reacting. 

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPUTResourceIdUnreactJsonRequest
 */
func (a *ReactionsV2ApiService) PUTResourceIdUnreactJson(ctx _context.Context, id string) ApiPUTResourceIdUnreactJsonRequest {
	return ApiPUTResourceIdUnreactJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20085
 */
func (a *ReactionsV2ApiService) PUTResourceIdUnreactJsonExecute(r ApiPUTResourceIdUnreactJsonRequest) (InlineResponse20085, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20085
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReactionsV2ApiService.PUTResourceIdUnreactJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resource/{id}/unreact.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
