/*
 * Teamwork.com Projects API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 3.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package projv3

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// ProjectsApiService ProjectsApi service
type ProjectsApiService service

type ApiGETProjectsApiV3ProjectsCsvRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	updatedAfter *time.Time
	searchTerm *string
	reportType *string
	reportFormat *string
	projectType *string
	projectStatuses *string
	orderMode *string
	orderBy *string
	minLastActivityDate *string
	maxLastActivityDate *string
	userId *int32
	projectHealths *int32
	pageSize *int32
	page *int32
	onlyStarredProjects *bool
	onlyProjectsWithExplicitMembership *bool
	onlyArchivedProjects *bool
	matchAllProjectTags *bool
	isReportDownload *bool
	includeProjectUserInfo *bool
	includeCustomFields *bool
	includeCompletedStatus *bool
	includeArchivedProjects *bool
	hideObservedProjects *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
	include *[]string
	fieldsUsers *[]string
	fieldsTags *[]string
	fieldsProjects *[]string
	fieldsProjectcategories *[]string
	fieldsProjectUpdates *[]string
	fieldsProjectBudgets *[]string
	fieldsPortfolioColumns *[]string
	fieldsPortfolioCards *[]string
	fieldsPortfolioBoards *[]string
	fieldsCustomfields *[]string
	fieldsCustomfieldProjects *[]string
	fieldsCompanies *[]string
}

func (r ApiGETProjectsApiV3ProjectsCsvRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) SearchTerm(searchTerm string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) ReportType(reportType string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.reportType = &reportType
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) ReportFormat(reportFormat string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.reportFormat = &reportFormat
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) ProjectType(projectType string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) OrderMode(orderMode string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) OrderBy(orderBy string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) MinLastActivityDate(minLastActivityDate string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.minLastActivityDate = &minLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) MaxLastActivityDate(maxLastActivityDate string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.maxLastActivityDate = &maxLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) UserId(userId int32) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.userId = &userId
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) PageSize(pageSize int32) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) Page(page int32) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) OnlyProjectsWithExplicitMembership(onlyProjectsWithExplicitMembership bool) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.onlyProjectsWithExplicitMembership = &onlyProjectsWithExplicitMembership
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) OnlyArchivedProjects(onlyArchivedProjects bool) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.onlyArchivedProjects = &onlyArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) IsReportDownload(isReportDownload bool) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.isReportDownload = &isReportDownload
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) IncludeProjectUserInfo(includeProjectUserInfo bool) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.includeProjectUserInfo = &includeProjectUserInfo
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) IncludeCustomFields(includeCustomFields bool) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.includeCustomFields = &includeCustomFields
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) IncludeCompletedStatus(includeCompletedStatus bool) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.includeCompletedStatus = &includeCompletedStatus
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) HideObservedProjects(hideObservedProjects bool) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.hideObservedProjects = &hideObservedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) Include(include []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsTags(fieldsTags []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsTags = &fieldsTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsProjectcategories(fieldsProjectcategories []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsProjectcategories = &fieldsProjectcategories
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsProjectUpdates(fieldsProjectUpdates []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsProjectUpdates = &fieldsProjectUpdates
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsProjectBudgets(fieldsProjectBudgets []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsProjectBudgets = &fieldsProjectBudgets
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsPortfolioColumns(fieldsPortfolioColumns []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsPortfolioColumns = &fieldsPortfolioColumns
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsPortfolioCards(fieldsPortfolioCards []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsPortfolioCards = &fieldsPortfolioCards
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsPortfolioBoards(fieldsPortfolioBoards []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsPortfolioBoards = &fieldsPortfolioBoards
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsCustomfields(fieldsCustomfields []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsCustomfields = &fieldsCustomfields
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsCustomfieldProjects(fieldsCustomfieldProjects []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsCustomfieldProjects = &fieldsCustomfieldProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsCsvRequest) FieldsCompanies(fieldsCompanies []string) ApiGETProjectsApiV3ProjectsCsvRequest {
	r.fieldsCompanies = &fieldsCompanies
	return r
}

func (r ApiGETProjectsApiV3ProjectsCsvRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsCsvExecute(r)
}

/*
 * GETProjectsApiV3ProjectsCsv Generate project report in CSV format
 * Generates a project report in CSV format containing all projects for the
provided filters. Only the projects that the logged-in user can access will
be returned.


On this endpoint you can filter by project custom fields. The syntax for the
query parameter is the following:

    projectCustomField[id][op]=value

Where:
  - [id] is the custom field ID
  - [op] is the operator to apply when filtering, different operators are
    allowed according to the custom field type
  - [value] is the value to apply when filtering

For example, if I want to filter a dropdown custom field with ID 10 to only
return entries that have the value "Option1" we would do the following:

    projectCustomField[10][eq]=Option1

The allowed operators are:
  - like
  - not-like
  - eq
  - not
  - lt
  - gt
  - any
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsCsvRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsCsv(ctx _context.Context) ApiGETProjectsApiV3ProjectsCsvRequest {
	return ApiGETProjectsApiV3ProjectsCsvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsCsvExecute(r ApiGETProjectsApiV3ProjectsCsvRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsCsv")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects.csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.reportType != nil {
		localVarQueryParams.Add("reportType", parameterToString(*r.reportType, ""))
	}
	if r.reportFormat != nil {
		localVarQueryParams.Add("reportFormat", parameterToString(*r.reportFormat, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.minLastActivityDate != nil {
		localVarQueryParams.Add("minLastActivityDate", parameterToString(*r.minLastActivityDate, ""))
	}
	if r.maxLastActivityDate != nil {
		localVarQueryParams.Add("maxLastActivityDate", parameterToString(*r.maxLastActivityDate, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.onlyProjectsWithExplicitMembership != nil {
		localVarQueryParams.Add("onlyProjectsWithExplicitMembership", parameterToString(*r.onlyProjectsWithExplicitMembership, ""))
	}
	if r.onlyArchivedProjects != nil {
		localVarQueryParams.Add("onlyArchivedProjects", parameterToString(*r.onlyArchivedProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.isReportDownload != nil {
		localVarQueryParams.Add("isReportDownload", parameterToString(*r.isReportDownload, ""))
	}
	if r.includeProjectUserInfo != nil {
		localVarQueryParams.Add("includeProjectUserInfo", parameterToString(*r.includeProjectUserInfo, ""))
	}
	if r.includeCustomFields != nil {
		localVarQueryParams.Add("includeCustomFields", parameterToString(*r.includeCustomFields, ""))
	}
	if r.includeCompletedStatus != nil {
		localVarQueryParams.Add("includeCompletedStatus", parameterToString(*r.includeCompletedStatus, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.hideObservedProjects != nil {
		localVarQueryParams.Add("hideObservedProjects", parameterToString(*r.hideObservedProjects, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsTags != nil {
		localVarQueryParams.Add("fields[tags]", parameterToString(*r.fieldsTags, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsProjectcategories != nil {
		localVarQueryParams.Add("fields[projectcategories]", parameterToString(*r.fieldsProjectcategories, "csv"))
	}
	if r.fieldsProjectUpdates != nil {
		localVarQueryParams.Add("fields[projectUpdates]", parameterToString(*r.fieldsProjectUpdates, "csv"))
	}
	if r.fieldsProjectBudgets != nil {
		localVarQueryParams.Add("fields[projectBudgets]", parameterToString(*r.fieldsProjectBudgets, "csv"))
	}
	if r.fieldsPortfolioColumns != nil {
		localVarQueryParams.Add("fields[portfolioColumns]", parameterToString(*r.fieldsPortfolioColumns, "csv"))
	}
	if r.fieldsPortfolioCards != nil {
		localVarQueryParams.Add("fields[portfolioCards]", parameterToString(*r.fieldsPortfolioCards, "csv"))
	}
	if r.fieldsPortfolioBoards != nil {
		localVarQueryParams.Add("fields[portfolioBoards]", parameterToString(*r.fieldsPortfolioBoards, "csv"))
	}
	if r.fieldsCustomfields != nil {
		localVarQueryParams.Add("fields[customfields]", parameterToString(*r.fieldsCustomfields, "csv"))
	}
	if r.fieldsCustomfieldProjects != nil {
		localVarQueryParams.Add("fields[customfieldProjects]", parameterToString(*r.fieldsCustomfieldProjects, "csv"))
	}
	if r.fieldsCompanies != nil {
		localVarQueryParams.Add("fields[companies]", parameterToString(*r.fieldsCompanies, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsHtmlRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	updatedAfter *time.Time
	searchTerm *string
	reportType *string
	reportFormat *string
	projectType *string
	projectStatuses *string
	orderMode *string
	orderBy *string
	minLastActivityDate *string
	maxLastActivityDate *string
	userId *int32
	projectHealths *int32
	pageSize *int32
	page *int32
	onlyStarredProjects *bool
	onlyProjectsWithExplicitMembership *bool
	onlyArchivedProjects *bool
	matchAllProjectTags *bool
	isReportDownload *bool
	includeProjectUserInfo *bool
	includeCustomFields *bool
	includeCompletedStatus *bool
	includeArchivedProjects *bool
	hideObservedProjects *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
	include *[]string
	fieldsUsers *[]string
	fieldsTags *[]string
	fieldsProjects *[]string
	fieldsProjectcategories *[]string
	fieldsProjectUpdates *[]string
	fieldsProjectBudgets *[]string
	fieldsPortfolioColumns *[]string
	fieldsPortfolioCards *[]string
	fieldsPortfolioBoards *[]string
	fieldsCustomfields *[]string
	fieldsCustomfieldProjects *[]string
	fieldsCompanies *[]string
}

func (r ApiGETProjectsApiV3ProjectsHtmlRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) SearchTerm(searchTerm string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) ReportType(reportType string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.reportType = &reportType
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) ReportFormat(reportFormat string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.reportFormat = &reportFormat
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) ProjectType(projectType string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) OrderMode(orderMode string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) OrderBy(orderBy string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) MinLastActivityDate(minLastActivityDate string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.minLastActivityDate = &minLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) MaxLastActivityDate(maxLastActivityDate string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.maxLastActivityDate = &maxLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) UserId(userId int32) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.userId = &userId
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) PageSize(pageSize int32) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) Page(page int32) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) OnlyProjectsWithExplicitMembership(onlyProjectsWithExplicitMembership bool) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.onlyProjectsWithExplicitMembership = &onlyProjectsWithExplicitMembership
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) OnlyArchivedProjects(onlyArchivedProjects bool) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.onlyArchivedProjects = &onlyArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) IsReportDownload(isReportDownload bool) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.isReportDownload = &isReportDownload
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) IncludeProjectUserInfo(includeProjectUserInfo bool) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.includeProjectUserInfo = &includeProjectUserInfo
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) IncludeCustomFields(includeCustomFields bool) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.includeCustomFields = &includeCustomFields
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) IncludeCompletedStatus(includeCompletedStatus bool) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.includeCompletedStatus = &includeCompletedStatus
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) HideObservedProjects(hideObservedProjects bool) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.hideObservedProjects = &hideObservedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) Include(include []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsTags(fieldsTags []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsTags = &fieldsTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsProjectcategories(fieldsProjectcategories []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsProjectcategories = &fieldsProjectcategories
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsProjectUpdates(fieldsProjectUpdates []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsProjectUpdates = &fieldsProjectUpdates
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsProjectBudgets(fieldsProjectBudgets []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsProjectBudgets = &fieldsProjectBudgets
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsPortfolioColumns(fieldsPortfolioColumns []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsPortfolioColumns = &fieldsPortfolioColumns
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsPortfolioCards(fieldsPortfolioCards []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsPortfolioCards = &fieldsPortfolioCards
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsPortfolioBoards(fieldsPortfolioBoards []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsPortfolioBoards = &fieldsPortfolioBoards
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsCustomfields(fieldsCustomfields []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsCustomfields = &fieldsCustomfields
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsCustomfieldProjects(fieldsCustomfieldProjects []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsCustomfieldProjects = &fieldsCustomfieldProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsHtmlRequest) FieldsCompanies(fieldsCompanies []string) ApiGETProjectsApiV3ProjectsHtmlRequest {
	r.fieldsCompanies = &fieldsCompanies
	return r
}

func (r ApiGETProjectsApiV3ProjectsHtmlRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsHtmlExecute(r)
}

/*
 * GETProjectsApiV3ProjectsHtml Generate project report in HTML format
 * Generates a project report in HTML format containing all projects for the
provided filters. Only the projects that the logged-in user can access will
be returned.


On this endpoint you can filter by project custom fields. The syntax for the
query parameter is the following:

    projectCustomField[id][op]=value

Where:
  - [id] is the custom field ID
  - [op] is the operator to apply when filtering, different operators are
    allowed according to the custom field type
  - [value] is the value to apply when filtering

For example, if I want to filter a dropdown custom field with ID 10 to only
return entries that have the value "Option1" we would do the following:

    projectCustomField[10][eq]=Option1

The allowed operators are:
  - like
  - not-like
  - eq
  - not
  - lt
  - gt
  - any
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsHtmlRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsHtml(ctx _context.Context) ApiGETProjectsApiV3ProjectsHtmlRequest {
	return ApiGETProjectsApiV3ProjectsHtmlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsHtmlExecute(r ApiGETProjectsApiV3ProjectsHtmlRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsHtml")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects.html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.reportType != nil {
		localVarQueryParams.Add("reportType", parameterToString(*r.reportType, ""))
	}
	if r.reportFormat != nil {
		localVarQueryParams.Add("reportFormat", parameterToString(*r.reportFormat, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.minLastActivityDate != nil {
		localVarQueryParams.Add("minLastActivityDate", parameterToString(*r.minLastActivityDate, ""))
	}
	if r.maxLastActivityDate != nil {
		localVarQueryParams.Add("maxLastActivityDate", parameterToString(*r.maxLastActivityDate, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.onlyProjectsWithExplicitMembership != nil {
		localVarQueryParams.Add("onlyProjectsWithExplicitMembership", parameterToString(*r.onlyProjectsWithExplicitMembership, ""))
	}
	if r.onlyArchivedProjects != nil {
		localVarQueryParams.Add("onlyArchivedProjects", parameterToString(*r.onlyArchivedProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.isReportDownload != nil {
		localVarQueryParams.Add("isReportDownload", parameterToString(*r.isReportDownload, ""))
	}
	if r.includeProjectUserInfo != nil {
		localVarQueryParams.Add("includeProjectUserInfo", parameterToString(*r.includeProjectUserInfo, ""))
	}
	if r.includeCustomFields != nil {
		localVarQueryParams.Add("includeCustomFields", parameterToString(*r.includeCustomFields, ""))
	}
	if r.includeCompletedStatus != nil {
		localVarQueryParams.Add("includeCompletedStatus", parameterToString(*r.includeCompletedStatus, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.hideObservedProjects != nil {
		localVarQueryParams.Add("hideObservedProjects", parameterToString(*r.hideObservedProjects, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsTags != nil {
		localVarQueryParams.Add("fields[tags]", parameterToString(*r.fieldsTags, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsProjectcategories != nil {
		localVarQueryParams.Add("fields[projectcategories]", parameterToString(*r.fieldsProjectcategories, "csv"))
	}
	if r.fieldsProjectUpdates != nil {
		localVarQueryParams.Add("fields[projectUpdates]", parameterToString(*r.fieldsProjectUpdates, "csv"))
	}
	if r.fieldsProjectBudgets != nil {
		localVarQueryParams.Add("fields[projectBudgets]", parameterToString(*r.fieldsProjectBudgets, "csv"))
	}
	if r.fieldsPortfolioColumns != nil {
		localVarQueryParams.Add("fields[portfolioColumns]", parameterToString(*r.fieldsPortfolioColumns, "csv"))
	}
	if r.fieldsPortfolioCards != nil {
		localVarQueryParams.Add("fields[portfolioCards]", parameterToString(*r.fieldsPortfolioCards, "csv"))
	}
	if r.fieldsPortfolioBoards != nil {
		localVarQueryParams.Add("fields[portfolioBoards]", parameterToString(*r.fieldsPortfolioBoards, "csv"))
	}
	if r.fieldsCustomfields != nil {
		localVarQueryParams.Add("fields[customfields]", parameterToString(*r.fieldsCustomfields, "csv"))
	}
	if r.fieldsCustomfieldProjects != nil {
		localVarQueryParams.Add("fields[customfieldProjects]", parameterToString(*r.fieldsCustomfieldProjects, "csv"))
	}
	if r.fieldsCompanies != nil {
		localVarQueryParams.Add("fields[companies]", parameterToString(*r.fieldsCompanies, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	updatedAfter *time.Time
	searchTerm *string
	reportType *string
	reportFormat *string
	projectType *string
	projectStatuses *string
	orderMode *string
	orderBy *string
	minLastActivityDate *string
	maxLastActivityDate *string
	userId *int32
	projectHealths *int32
	pageSize *int32
	page *int32
	onlyStarredProjects *bool
	onlyProjectsWithExplicitMembership *bool
	onlyArchivedProjects *bool
	matchAllProjectTags *bool
	isReportDownload *bool
	includeProjectUserInfo *bool
	includeCustomFields *bool
	includeCompletedStatus *bool
	includeArchivedProjects *bool
	hideObservedProjects *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
	include *[]string
	fieldsUsers *[]string
	fieldsTags *[]string
	fieldsProjects *[]string
	fieldsProjectcategories *[]string
	fieldsProjectUpdates *[]string
	fieldsProjectBudgets *[]string
	fieldsPortfolioColumns *[]string
	fieldsPortfolioCards *[]string
	fieldsPortfolioBoards *[]string
	fieldsCustomfields *[]string
	fieldsCustomfieldProjects *[]string
	fieldsCompanies *[]string
}

func (r ApiGETProjectsApiV3ProjectsJsonRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) SearchTerm(searchTerm string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) ReportType(reportType string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.reportType = &reportType
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) ReportFormat(reportFormat string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.reportFormat = &reportFormat
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) ProjectType(projectType string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) OrderMode(orderMode string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) OrderBy(orderBy string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) MinLastActivityDate(minLastActivityDate string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.minLastActivityDate = &minLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) MaxLastActivityDate(maxLastActivityDate string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.maxLastActivityDate = &maxLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) UserId(userId int32) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.userId = &userId
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) PageSize(pageSize int32) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) Page(page int32) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) OnlyProjectsWithExplicitMembership(onlyProjectsWithExplicitMembership bool) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.onlyProjectsWithExplicitMembership = &onlyProjectsWithExplicitMembership
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) OnlyArchivedProjects(onlyArchivedProjects bool) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.onlyArchivedProjects = &onlyArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) IsReportDownload(isReportDownload bool) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.isReportDownload = &isReportDownload
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) IncludeProjectUserInfo(includeProjectUserInfo bool) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.includeProjectUserInfo = &includeProjectUserInfo
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) IncludeCustomFields(includeCustomFields bool) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.includeCustomFields = &includeCustomFields
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) IncludeCompletedStatus(includeCompletedStatus bool) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.includeCompletedStatus = &includeCompletedStatus
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) HideObservedProjects(hideObservedProjects bool) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.hideObservedProjects = &hideObservedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) Include(include []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsTags(fieldsTags []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsTags = &fieldsTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsProjectcategories(fieldsProjectcategories []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsProjectcategories = &fieldsProjectcategories
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsProjectUpdates(fieldsProjectUpdates []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsProjectUpdates = &fieldsProjectUpdates
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsProjectBudgets(fieldsProjectBudgets []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsProjectBudgets = &fieldsProjectBudgets
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsPortfolioColumns(fieldsPortfolioColumns []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsPortfolioColumns = &fieldsPortfolioColumns
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsPortfolioCards(fieldsPortfolioCards []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsPortfolioCards = &fieldsPortfolioCards
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsPortfolioBoards(fieldsPortfolioBoards []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsPortfolioBoards = &fieldsPortfolioBoards
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsCustomfields(fieldsCustomfields []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsCustomfields = &fieldsCustomfields
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsCustomfieldProjects(fieldsCustomfieldProjects []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsCustomfieldProjects = &fieldsCustomfieldProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsJsonRequest) FieldsCompanies(fieldsCompanies []string) ApiGETProjectsApiV3ProjectsJsonRequest {
	r.fieldsCompanies = &fieldsCompanies
	return r
}

func (r ApiGETProjectsApiV3ProjectsJsonRequest) Execute() (ProjectProjectsResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsJson Returns a list of projects
 * Retrieve all projects for the provided filters. Only the projects that the
logged-in user can access will be returned.


On this endpoint you can filter by project custom fields. The syntax for the
query parameter is the following:

    projectCustomField[id][op]=value

Where:
  - [id] is the custom field ID
  - [op] is the operator to apply when filtering, different operators are
    allowed according to the custom field type
  - [value] is the value to apply when filtering

For example, if I want to filter a dropdown custom field with ID 10 to only
return entries that have the value "Option1" we would do the following:

    projectCustomField[10][eq]=Option1

The allowed operators are:
  - like
  - not-like
  - eq
  - not
  - lt
  - gt
  - any
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsJson(ctx _context.Context) ApiGETProjectsApiV3ProjectsJsonRequest {
	return ApiGETProjectsApiV3ProjectsJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ProjectProjectsResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsJsonExecute(r ApiGETProjectsApiV3ProjectsJsonRequest) (ProjectProjectsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProjectProjectsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.reportType != nil {
		localVarQueryParams.Add("reportType", parameterToString(*r.reportType, ""))
	}
	if r.reportFormat != nil {
		localVarQueryParams.Add("reportFormat", parameterToString(*r.reportFormat, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.minLastActivityDate != nil {
		localVarQueryParams.Add("minLastActivityDate", parameterToString(*r.minLastActivityDate, ""))
	}
	if r.maxLastActivityDate != nil {
		localVarQueryParams.Add("maxLastActivityDate", parameterToString(*r.maxLastActivityDate, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.onlyProjectsWithExplicitMembership != nil {
		localVarQueryParams.Add("onlyProjectsWithExplicitMembership", parameterToString(*r.onlyProjectsWithExplicitMembership, ""))
	}
	if r.onlyArchivedProjects != nil {
		localVarQueryParams.Add("onlyArchivedProjects", parameterToString(*r.onlyArchivedProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.isReportDownload != nil {
		localVarQueryParams.Add("isReportDownload", parameterToString(*r.isReportDownload, ""))
	}
	if r.includeProjectUserInfo != nil {
		localVarQueryParams.Add("includeProjectUserInfo", parameterToString(*r.includeProjectUserInfo, ""))
	}
	if r.includeCustomFields != nil {
		localVarQueryParams.Add("includeCustomFields", parameterToString(*r.includeCustomFields, ""))
	}
	if r.includeCompletedStatus != nil {
		localVarQueryParams.Add("includeCompletedStatus", parameterToString(*r.includeCompletedStatus, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.hideObservedProjects != nil {
		localVarQueryParams.Add("hideObservedProjects", parameterToString(*r.hideObservedProjects, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsTags != nil {
		localVarQueryParams.Add("fields[tags]", parameterToString(*r.fieldsTags, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsProjectcategories != nil {
		localVarQueryParams.Add("fields[projectcategories]", parameterToString(*r.fieldsProjectcategories, "csv"))
	}
	if r.fieldsProjectUpdates != nil {
		localVarQueryParams.Add("fields[projectUpdates]", parameterToString(*r.fieldsProjectUpdates, "csv"))
	}
	if r.fieldsProjectBudgets != nil {
		localVarQueryParams.Add("fields[projectBudgets]", parameterToString(*r.fieldsProjectBudgets, "csv"))
	}
	if r.fieldsPortfolioColumns != nil {
		localVarQueryParams.Add("fields[portfolioColumns]", parameterToString(*r.fieldsPortfolioColumns, "csv"))
	}
	if r.fieldsPortfolioCards != nil {
		localVarQueryParams.Add("fields[portfolioCards]", parameterToString(*r.fieldsPortfolioCards, "csv"))
	}
	if r.fieldsPortfolioBoards != nil {
		localVarQueryParams.Add("fields[portfolioBoards]", parameterToString(*r.fieldsPortfolioBoards, "csv"))
	}
	if r.fieldsCustomfields != nil {
		localVarQueryParams.Add("fields[customfields]", parameterToString(*r.fieldsCustomfields, "csv"))
	}
	if r.fieldsCustomfieldProjects != nil {
		localVarQueryParams.Add("fields[customfieldProjects]", parameterToString(*r.fieldsCustomfieldProjects, "csv"))
	}
	if r.fieldsCompanies != nil {
		localVarQueryParams.Add("fields[companies]", parameterToString(*r.fieldsCompanies, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsMetricsActiveJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
}


func (r ApiGETProjectsApiV3ProjectsMetricsActiveJsonRequest) Execute() (ActiveResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsMetricsActiveJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsMetricsActiveJson Get the total count of active projects
 * Return the number of active projects that the logged-in user can access.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsMetricsActiveJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsActiveJson(ctx _context.Context) ApiGETProjectsApiV3ProjectsMetricsActiveJsonRequest {
	return ApiGETProjectsApiV3ProjectsMetricsActiveJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ActiveResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsActiveJsonExecute(r ApiGETProjectsApiV3ProjectsMetricsActiveJsonRequest) (ActiveResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsMetricsActiveJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/metrics/active.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	startDate *string
	orderMode *string
	endDate *string
}

func (r ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest) StartDate(startDate string) ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest {
	r.startDate = &startDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest) OrderMode(orderMode string) ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest) EndDate(endDate string) ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest {
	r.endDate = &endDate
	return r
}

func (r ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest) Execute() (BillableProjectMetricBillablesResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsMetricsBillableJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsMetricsBillableJson Get the total billable time per project
 * Returns the total billable time of all projects that the logged-in user has
access.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsBillableJson(ctx _context.Context) ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest {
	return ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return BillableProjectMetricBillablesResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsBillableJsonExecute(r ApiGETProjectsApiV3ProjectsMetricsBillableJsonRequest) (BillableProjectMetricBillablesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BillableProjectMetricBillablesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsMetricsBillableJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/metrics/billable.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	projectStatuses *string
	projectStatus *string
	projectHealths *int32
	onlyStarredProjects *bool
	matchAllProjectTags *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
}

func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) ProjectStatus(projectStatus string) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	r.projectStatus = &projectStatus
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}

func (r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) Execute() (HealthProjectMetricHealthsResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsMetricsHealthsJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsMetricsHealthsJson Get a health summary for all projects
 * Return the number of projects on each health category. It will only count the
projects that the logged-in user can access.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsHealthsJson(ctx _context.Context) ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest {
	return ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return HealthProjectMetricHealthsResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsHealthsJsonExecute(r ApiGETProjectsApiV3ProjectsMetricsHealthsJsonRequest) (HealthProjectMetricHealthsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HealthProjectMetricHealthsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsMetricsHealthsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/metrics/healths.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.projectStatus != nil {
		localVarQueryParams.Add("projectStatus", parameterToString(*r.projectStatus, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	projectStatuses *string
	projectHealths *int32
	onlyStarredProjects *bool
	matchAllProjectTags *bool
	includeArchivedProjects *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
}

func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}

func (r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) Execute() (InvoiceProjectMetricInvoicesResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsMetricsInvoiceJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsMetricsInvoiceJson Return open invoices across all projects
 * Count the number of open invoices on all projects that the logged-in user has
access.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsInvoiceJson(ctx _context.Context) ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest {
	return ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InvoiceProjectMetricInvoicesResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsInvoiceJsonExecute(r ApiGETProjectsApiV3ProjectsMetricsInvoiceJsonRequest) (InvoiceProjectMetricInvoicesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InvoiceProjectMetricInvoicesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsMetricsInvoiceJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/metrics/invoice.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	projectStatuses *string
	orderMode *string
	projectHealths *int32
	pageSize *int32
	page *int32
	onlyStarredProjects *bool
	matchAllProjectTags *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
}

func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) OrderMode(orderMode string) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) PageSize(pageSize int32) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) Page(page int32) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}

func (r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) Execute() (OwnerProjectMetricOwnersResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsMetricsOwnersJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsMetricsOwnersJson Get number of owned and un-assigned projects
 * Count the number of projects per project owner user.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsOwnersJson(ctx _context.Context) ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest {
	return ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OwnerProjectMetricOwnersResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsOwnersJsonExecute(r ApiGETProjectsApiV3ProjectsMetricsOwnersJsonRequest) (OwnerProjectMetricOwnersResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OwnerProjectMetricOwnersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsMetricsOwnersJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/metrics/owners.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	projectStatuses *string
	projectHealths *int32
	onlyStarredProjects *bool
	matchAllProjectTags *bool
	includeArchivedProjects *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
}

func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}

func (r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) Execute() (UnbilledProjectMetricUnbilledResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsMetricsUnbilledJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsMetricsUnbilledJson Return un-billed expenses across all projects
 * Return the un-billed expenses for each project that the logged-in user has
access.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsUnbilledJson(ctx _context.Context) ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest {
	return ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return UnbilledProjectMetricUnbilledResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsMetricsUnbilledJsonExecute(r ApiGETProjectsApiV3ProjectsMetricsUnbilledJsonRequest) (UnbilledProjectMetricUnbilledResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UnbilledProjectMetricUnbilledResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsMetricsUnbilledJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/metrics/unbilled.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsPdfRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	updatedAfter *time.Time
	searchTerm *string
	reportType *string
	reportFormat *string
	projectType *string
	projectStatuses *string
	orderMode *string
	orderBy *string
	minLastActivityDate *string
	maxLastActivityDate *string
	userId *int32
	projectHealths *int32
	pageSize *int32
	page *int32
	onlyStarredProjects *bool
	onlyProjectsWithExplicitMembership *bool
	onlyArchivedProjects *bool
	matchAllProjectTags *bool
	isReportDownload *bool
	includeProjectUserInfo *bool
	includeCustomFields *bool
	includeCompletedStatus *bool
	includeArchivedProjects *bool
	hideObservedProjects *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
	include *[]string
	fieldsUsers *[]string
	fieldsTags *[]string
	fieldsProjects *[]string
	fieldsProjectcategories *[]string
	fieldsProjectUpdates *[]string
	fieldsProjectBudgets *[]string
	fieldsPortfolioColumns *[]string
	fieldsPortfolioCards *[]string
	fieldsPortfolioBoards *[]string
	fieldsCustomfields *[]string
	fieldsCustomfieldProjects *[]string
	fieldsCompanies *[]string
}

func (r ApiGETProjectsApiV3ProjectsPdfRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) SearchTerm(searchTerm string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) ReportType(reportType string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.reportType = &reportType
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) ReportFormat(reportFormat string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.reportFormat = &reportFormat
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) ProjectType(projectType string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) OrderMode(orderMode string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) OrderBy(orderBy string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) MinLastActivityDate(minLastActivityDate string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.minLastActivityDate = &minLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) MaxLastActivityDate(maxLastActivityDate string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.maxLastActivityDate = &maxLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) UserId(userId int32) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.userId = &userId
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) PageSize(pageSize int32) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) Page(page int32) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) OnlyProjectsWithExplicitMembership(onlyProjectsWithExplicitMembership bool) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.onlyProjectsWithExplicitMembership = &onlyProjectsWithExplicitMembership
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) OnlyArchivedProjects(onlyArchivedProjects bool) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.onlyArchivedProjects = &onlyArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) IsReportDownload(isReportDownload bool) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.isReportDownload = &isReportDownload
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) IncludeProjectUserInfo(includeProjectUserInfo bool) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.includeProjectUserInfo = &includeProjectUserInfo
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) IncludeCustomFields(includeCustomFields bool) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.includeCustomFields = &includeCustomFields
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) IncludeCompletedStatus(includeCompletedStatus bool) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.includeCompletedStatus = &includeCompletedStatus
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) HideObservedProjects(hideObservedProjects bool) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.hideObservedProjects = &hideObservedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) Include(include []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsTags(fieldsTags []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsTags = &fieldsTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsProjectcategories(fieldsProjectcategories []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsProjectcategories = &fieldsProjectcategories
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsProjectUpdates(fieldsProjectUpdates []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsProjectUpdates = &fieldsProjectUpdates
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsProjectBudgets(fieldsProjectBudgets []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsProjectBudgets = &fieldsProjectBudgets
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsPortfolioColumns(fieldsPortfolioColumns []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsPortfolioColumns = &fieldsPortfolioColumns
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsPortfolioCards(fieldsPortfolioCards []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsPortfolioCards = &fieldsPortfolioCards
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsPortfolioBoards(fieldsPortfolioBoards []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsPortfolioBoards = &fieldsPortfolioBoards
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsCustomfields(fieldsCustomfields []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsCustomfields = &fieldsCustomfields
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsCustomfieldProjects(fieldsCustomfieldProjects []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsCustomfieldProjects = &fieldsCustomfieldProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsPdfRequest) FieldsCompanies(fieldsCompanies []string) ApiGETProjectsApiV3ProjectsPdfRequest {
	r.fieldsCompanies = &fieldsCompanies
	return r
}

func (r ApiGETProjectsApiV3ProjectsPdfRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsPdfExecute(r)
}

/*
 * GETProjectsApiV3ProjectsPdf Generate project report in PDF format
 * Generates a project report in PDF format containing all projects for the
provided filters. Only the projects that the logged-in user can access will
be returned.


On this endpoint you can filter by project custom fields. The syntax for the
query parameter is the following:

    projectCustomField[id][op]=value

Where:
  - [id] is the custom field ID
  - [op] is the operator to apply when filtering, different operators are
    allowed according to the custom field type
  - [value] is the value to apply when filtering

For example, if I want to filter a dropdown custom field with ID 10 to only
return entries that have the value "Option1" we would do the following:

    projectCustomField[10][eq]=Option1

The allowed operators are:
  - like
  - not-like
  - eq
  - not
  - lt
  - gt
  - any
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsPdfRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsPdf(ctx _context.Context) ApiGETProjectsApiV3ProjectsPdfRequest {
	return ApiGETProjectsApiV3ProjectsPdfRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsPdfExecute(r ApiGETProjectsApiV3ProjectsPdfRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsPdf")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects.pdf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.reportType != nil {
		localVarQueryParams.Add("reportType", parameterToString(*r.reportType, ""))
	}
	if r.reportFormat != nil {
		localVarQueryParams.Add("reportFormat", parameterToString(*r.reportFormat, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.minLastActivityDate != nil {
		localVarQueryParams.Add("minLastActivityDate", parameterToString(*r.minLastActivityDate, ""))
	}
	if r.maxLastActivityDate != nil {
		localVarQueryParams.Add("maxLastActivityDate", parameterToString(*r.maxLastActivityDate, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.onlyProjectsWithExplicitMembership != nil {
		localVarQueryParams.Add("onlyProjectsWithExplicitMembership", parameterToString(*r.onlyProjectsWithExplicitMembership, ""))
	}
	if r.onlyArchivedProjects != nil {
		localVarQueryParams.Add("onlyArchivedProjects", parameterToString(*r.onlyArchivedProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.isReportDownload != nil {
		localVarQueryParams.Add("isReportDownload", parameterToString(*r.isReportDownload, ""))
	}
	if r.includeProjectUserInfo != nil {
		localVarQueryParams.Add("includeProjectUserInfo", parameterToString(*r.includeProjectUserInfo, ""))
	}
	if r.includeCustomFields != nil {
		localVarQueryParams.Add("includeCustomFields", parameterToString(*r.includeCustomFields, ""))
	}
	if r.includeCompletedStatus != nil {
		localVarQueryParams.Add("includeCompletedStatus", parameterToString(*r.includeCompletedStatus, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.hideObservedProjects != nil {
		localVarQueryParams.Add("hideObservedProjects", parameterToString(*r.hideObservedProjects, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsTags != nil {
		localVarQueryParams.Add("fields[tags]", parameterToString(*r.fieldsTags, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsProjectcategories != nil {
		localVarQueryParams.Add("fields[projectcategories]", parameterToString(*r.fieldsProjectcategories, "csv"))
	}
	if r.fieldsProjectUpdates != nil {
		localVarQueryParams.Add("fields[projectUpdates]", parameterToString(*r.fieldsProjectUpdates, "csv"))
	}
	if r.fieldsProjectBudgets != nil {
		localVarQueryParams.Add("fields[projectBudgets]", parameterToString(*r.fieldsProjectBudgets, "csv"))
	}
	if r.fieldsPortfolioColumns != nil {
		localVarQueryParams.Add("fields[portfolioColumns]", parameterToString(*r.fieldsPortfolioColumns, "csv"))
	}
	if r.fieldsPortfolioCards != nil {
		localVarQueryParams.Add("fields[portfolioCards]", parameterToString(*r.fieldsPortfolioCards, "csv"))
	}
	if r.fieldsPortfolioBoards != nil {
		localVarQueryParams.Add("fields[portfolioBoards]", parameterToString(*r.fieldsPortfolioBoards, "csv"))
	}
	if r.fieldsCustomfields != nil {
		localVarQueryParams.Add("fields[customfields]", parameterToString(*r.fieldsCustomfields, "csv"))
	}
	if r.fieldsCustomfieldProjects != nil {
		localVarQueryParams.Add("fields[customfieldProjects]", parameterToString(*r.fieldsCustomfieldProjects, "csv"))
	}
	if r.fieldsCompanies != nil {
		localVarQueryParams.Add("fields[companies]", parameterToString(*r.fieldsCompanies, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/pdf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	searchTerm *string
	pageSize *int32
	page *int32
	ids *[]int32
	fieldsSampleprojects *[]string
	categoryIds *[]int32
}

func (r ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest) SearchTerm(searchTerm string) ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest) PageSize(pageSize int32) ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest) Page(page int32) ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest) Ids(ids []int32) ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest {
	r.ids = &ids
	return r
}
func (r ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest) FieldsSampleprojects(fieldsSampleprojects []string) ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest {
	r.fieldsSampleprojects = &fieldsSampleprojects
	return r
}
func (r ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest) CategoryIds(categoryIds []int32) ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest {
	r.categoryIds = &categoryIds
	return r
}

func (r ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest) Execute() (ProjectSampleProjectsResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsTeamworkSamplesJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsTeamworkSamplesJson Returns a list of teamwork sample projects
 * Retrieve all sample projects for the provided filters.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsTeamworkSamplesJson(ctx _context.Context) ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest {
	return ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ProjectSampleProjectsResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsTeamworkSamplesJsonExecute(r ApiGETProjectsApiV3ProjectsTeamworkSamplesJsonRequest) (ProjectSampleProjectsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProjectSampleProjectsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsTeamworkSamplesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/teamwork/samples.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, "csv"))
	}
	if r.fieldsSampleprojects != nil {
		localVarQueryParams.Add("fields[sampleprojects]", parameterToString(*r.fieldsSampleprojects, "csv"))
	}
	if r.categoryIds != nil {
		localVarQueryParams.Add("categoryIds", parameterToString(*r.categoryIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsTemplatesJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	updatedAfter *time.Time
	searchTerm *string
	reportType *string
	reportFormat *string
	projectType *string
	projectStatuses *string
	orderMode *string
	orderBy *string
	minLastActivityDate *string
	maxLastActivityDate *string
	userId *int32
	projectHealths *int32
	pageSize *int32
	page *int32
	onlyStarredProjects *bool
	onlyProjectsWithExplicitMembership *bool
	onlyArchivedProjects *bool
	matchAllProjectTags *bool
	isReportDownload *bool
	includeProjectUserInfo *bool
	includeCustomFields *bool
	includeCompletedStatus *bool
	includeArchivedProjects *bool
	hideObservedProjects *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
	include *[]string
	fieldsUsers *[]string
	fieldsTags *[]string
	fieldsProjects *[]string
	fieldsProjectcategories *[]string
	fieldsProjectUpdates *[]string
	fieldsProjectBudgets *[]string
	fieldsPortfolioColumns *[]string
	fieldsPortfolioCards *[]string
	fieldsPortfolioBoards *[]string
	fieldsCustomfields *[]string
	fieldsCustomfieldProjects *[]string
	fieldsCompanies *[]string
}

func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) SearchTerm(searchTerm string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) ReportType(reportType string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.reportType = &reportType
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) ReportFormat(reportFormat string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.reportFormat = &reportFormat
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) ProjectType(projectType string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) OrderMode(orderMode string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) OrderBy(orderBy string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) MinLastActivityDate(minLastActivityDate string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.minLastActivityDate = &minLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) MaxLastActivityDate(maxLastActivityDate string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.maxLastActivityDate = &maxLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) UserId(userId int32) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.userId = &userId
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) PageSize(pageSize int32) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) Page(page int32) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) OnlyProjectsWithExplicitMembership(onlyProjectsWithExplicitMembership bool) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.onlyProjectsWithExplicitMembership = &onlyProjectsWithExplicitMembership
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) OnlyArchivedProjects(onlyArchivedProjects bool) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.onlyArchivedProjects = &onlyArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) IsReportDownload(isReportDownload bool) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.isReportDownload = &isReportDownload
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) IncludeProjectUserInfo(includeProjectUserInfo bool) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.includeProjectUserInfo = &includeProjectUserInfo
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) IncludeCustomFields(includeCustomFields bool) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.includeCustomFields = &includeCustomFields
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) IncludeCompletedStatus(includeCompletedStatus bool) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.includeCompletedStatus = &includeCompletedStatus
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) HideObservedProjects(hideObservedProjects bool) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.hideObservedProjects = &hideObservedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) Include(include []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsTags(fieldsTags []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsTags = &fieldsTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsProjectcategories(fieldsProjectcategories []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsProjectcategories = &fieldsProjectcategories
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsProjectUpdates(fieldsProjectUpdates []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsProjectUpdates = &fieldsProjectUpdates
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsProjectBudgets(fieldsProjectBudgets []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsProjectBudgets = &fieldsProjectBudgets
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsPortfolioColumns(fieldsPortfolioColumns []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsPortfolioColumns = &fieldsPortfolioColumns
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsPortfolioCards(fieldsPortfolioCards []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsPortfolioCards = &fieldsPortfolioCards
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsPortfolioBoards(fieldsPortfolioBoards []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsPortfolioBoards = &fieldsPortfolioBoards
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsCustomfields(fieldsCustomfields []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsCustomfields = &fieldsCustomfields
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsCustomfieldProjects(fieldsCustomfieldProjects []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsCustomfieldProjects = &fieldsCustomfieldProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) FieldsCompanies(fieldsCompanies []string) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	r.fieldsCompanies = &fieldsCompanies
	return r
}

func (r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) Execute() (ProjectProjectsResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsTemplatesJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsTemplatesJson Returns a list of projects templates
 * Retrieve all projects templates for the provided filters. Only the projects templates that the
logged-in user can access will be returned.


On this endpoint you can filter by project custom fields. The syntax for the
query parameter is the following:

    projectCustomField[id][op]=value

Where:
  - [id] is the custom field ID
  - [op] is the operator to apply when filtering, different operators are
    allowed according to the custom field type
  - [value] is the value to apply when filtering

For example, if I want to filter a dropdown custom field with ID 10 to only
return entries that have the value "Option1" we would do the following:

    projectCustomField[10][eq]=Option1

The allowed operators are:
  - like
  - not-like
  - eq
  - not
  - lt
  - gt
  - any
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsTemplatesJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsTemplatesJson(ctx _context.Context) ApiGETProjectsApiV3ProjectsTemplatesJsonRequest {
	return ApiGETProjectsApiV3ProjectsTemplatesJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ProjectProjectsResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsTemplatesJsonExecute(r ApiGETProjectsApiV3ProjectsTemplatesJsonRequest) (ProjectProjectsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProjectProjectsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsTemplatesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/templates.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.reportType != nil {
		localVarQueryParams.Add("reportType", parameterToString(*r.reportType, ""))
	}
	if r.reportFormat != nil {
		localVarQueryParams.Add("reportFormat", parameterToString(*r.reportFormat, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.minLastActivityDate != nil {
		localVarQueryParams.Add("minLastActivityDate", parameterToString(*r.minLastActivityDate, ""))
	}
	if r.maxLastActivityDate != nil {
		localVarQueryParams.Add("maxLastActivityDate", parameterToString(*r.maxLastActivityDate, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.onlyProjectsWithExplicitMembership != nil {
		localVarQueryParams.Add("onlyProjectsWithExplicitMembership", parameterToString(*r.onlyProjectsWithExplicitMembership, ""))
	}
	if r.onlyArchivedProjects != nil {
		localVarQueryParams.Add("onlyArchivedProjects", parameterToString(*r.onlyArchivedProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.isReportDownload != nil {
		localVarQueryParams.Add("isReportDownload", parameterToString(*r.isReportDownload, ""))
	}
	if r.includeProjectUserInfo != nil {
		localVarQueryParams.Add("includeProjectUserInfo", parameterToString(*r.includeProjectUserInfo, ""))
	}
	if r.includeCustomFields != nil {
		localVarQueryParams.Add("includeCustomFields", parameterToString(*r.includeCustomFields, ""))
	}
	if r.includeCompletedStatus != nil {
		localVarQueryParams.Add("includeCompletedStatus", parameterToString(*r.includeCompletedStatus, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.hideObservedProjects != nil {
		localVarQueryParams.Add("hideObservedProjects", parameterToString(*r.hideObservedProjects, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsTags != nil {
		localVarQueryParams.Add("fields[tags]", parameterToString(*r.fieldsTags, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsProjectcategories != nil {
		localVarQueryParams.Add("fields[projectcategories]", parameterToString(*r.fieldsProjectcategories, "csv"))
	}
	if r.fieldsProjectUpdates != nil {
		localVarQueryParams.Add("fields[projectUpdates]", parameterToString(*r.fieldsProjectUpdates, "csv"))
	}
	if r.fieldsProjectBudgets != nil {
		localVarQueryParams.Add("fields[projectBudgets]", parameterToString(*r.fieldsProjectBudgets, "csv"))
	}
	if r.fieldsPortfolioColumns != nil {
		localVarQueryParams.Add("fields[portfolioColumns]", parameterToString(*r.fieldsPortfolioColumns, "csv"))
	}
	if r.fieldsPortfolioCards != nil {
		localVarQueryParams.Add("fields[portfolioCards]", parameterToString(*r.fieldsPortfolioCards, "csv"))
	}
	if r.fieldsPortfolioBoards != nil {
		localVarQueryParams.Add("fields[portfolioBoards]", parameterToString(*r.fieldsPortfolioBoards, "csv"))
	}
	if r.fieldsCustomfields != nil {
		localVarQueryParams.Add("fields[customfields]", parameterToString(*r.fieldsCustomfields, "csv"))
	}
	if r.fieldsCustomfieldProjects != nil {
		localVarQueryParams.Add("fields[customfieldProjects]", parameterToString(*r.fieldsCustomfieldProjects, "csv"))
	}
	if r.fieldsCompanies != nil {
		localVarQueryParams.Add("fields[companies]", parameterToString(*r.fieldsCompanies, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsXlsxRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	updatedAfter *time.Time
	searchTerm *string
	reportType *string
	reportFormat *string
	projectType *string
	projectStatuses *string
	orderMode *string
	orderBy *string
	minLastActivityDate *string
	maxLastActivityDate *string
	userId *int32
	projectHealths *int32
	pageSize *int32
	page *int32
	onlyStarredProjects *bool
	onlyProjectsWithExplicitMembership *bool
	onlyArchivedProjects *bool
	matchAllProjectTags *bool
	isReportDownload *bool
	includeProjectUserInfo *bool
	includeCustomFields *bool
	includeCompletedStatus *bool
	includeArchivedProjects *bool
	hideObservedProjects *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
	include *[]string
	fieldsUsers *[]string
	fieldsTags *[]string
	fieldsProjects *[]string
	fieldsProjectcategories *[]string
	fieldsProjectUpdates *[]string
	fieldsProjectBudgets *[]string
	fieldsPortfolioColumns *[]string
	fieldsPortfolioCards *[]string
	fieldsPortfolioBoards *[]string
	fieldsCustomfields *[]string
	fieldsCustomfieldProjects *[]string
	fieldsCompanies *[]string
}

func (r ApiGETProjectsApiV3ProjectsXlsxRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) SearchTerm(searchTerm string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) ReportType(reportType string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.reportType = &reportType
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) ReportFormat(reportFormat string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.reportFormat = &reportFormat
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) ProjectType(projectType string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) OrderMode(orderMode string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) OrderBy(orderBy string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) MinLastActivityDate(minLastActivityDate string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.minLastActivityDate = &minLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) MaxLastActivityDate(maxLastActivityDate string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.maxLastActivityDate = &maxLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) UserId(userId int32) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.userId = &userId
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) PageSize(pageSize int32) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) Page(page int32) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) OnlyProjectsWithExplicitMembership(onlyProjectsWithExplicitMembership bool) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.onlyProjectsWithExplicitMembership = &onlyProjectsWithExplicitMembership
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) OnlyArchivedProjects(onlyArchivedProjects bool) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.onlyArchivedProjects = &onlyArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) IsReportDownload(isReportDownload bool) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.isReportDownload = &isReportDownload
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) IncludeProjectUserInfo(includeProjectUserInfo bool) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.includeProjectUserInfo = &includeProjectUserInfo
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) IncludeCustomFields(includeCustomFields bool) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.includeCustomFields = &includeCustomFields
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) IncludeCompletedStatus(includeCompletedStatus bool) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.includeCompletedStatus = &includeCompletedStatus
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) HideObservedProjects(hideObservedProjects bool) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.hideObservedProjects = &hideObservedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) Include(include []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsTags(fieldsTags []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsTags = &fieldsTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsProjectcategories(fieldsProjectcategories []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsProjectcategories = &fieldsProjectcategories
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsProjectUpdates(fieldsProjectUpdates []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsProjectUpdates = &fieldsProjectUpdates
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsProjectBudgets(fieldsProjectBudgets []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsProjectBudgets = &fieldsProjectBudgets
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsPortfolioColumns(fieldsPortfolioColumns []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsPortfolioColumns = &fieldsPortfolioColumns
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsPortfolioCards(fieldsPortfolioCards []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsPortfolioCards = &fieldsPortfolioCards
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsPortfolioBoards(fieldsPortfolioBoards []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsPortfolioBoards = &fieldsPortfolioBoards
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsCustomfields(fieldsCustomfields []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsCustomfields = &fieldsCustomfields
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsCustomfieldProjects(fieldsCustomfieldProjects []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsCustomfieldProjects = &fieldsCustomfieldProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsXlsxRequest) FieldsCompanies(fieldsCompanies []string) ApiGETProjectsApiV3ProjectsXlsxRequest {
	r.fieldsCompanies = &fieldsCompanies
	return r
}

func (r ApiGETProjectsApiV3ProjectsXlsxRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsXlsxExecute(r)
}

/*
 * GETProjectsApiV3ProjectsXlsx Generate project report in XLSX format
 * Generates a project report in XLSX format containing all projects for the
provided filters. Only the projects that the logged-in user can access will
be returned.


On this endpoint you can filter by project custom fields. The syntax for the
query parameter is the following:

    projectCustomField[id][op]=value

Where:
  - [id] is the custom field ID
  - [op] is the operator to apply when filtering, different operators are
    allowed according to the custom field type
  - [value] is the value to apply when filtering

For example, if I want to filter a dropdown custom field with ID 10 to only
return entries that have the value "Option1" we would do the following:

    projectCustomField[10][eq]=Option1

The allowed operators are:
  - like
  - not-like
  - eq
  - not
  - lt
  - gt
  - any
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3ProjectsXlsxRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsXlsx(ctx _context.Context) ApiGETProjectsApiV3ProjectsXlsxRequest {
	return ApiGETProjectsApiV3ProjectsXlsxRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsXlsxExecute(r ApiGETProjectsApiV3ProjectsXlsxRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsXlsx")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects.xlsx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.reportType != nil {
		localVarQueryParams.Add("reportType", parameterToString(*r.reportType, ""))
	}
	if r.reportFormat != nil {
		localVarQueryParams.Add("reportFormat", parameterToString(*r.reportFormat, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.minLastActivityDate != nil {
		localVarQueryParams.Add("minLastActivityDate", parameterToString(*r.minLastActivityDate, ""))
	}
	if r.maxLastActivityDate != nil {
		localVarQueryParams.Add("maxLastActivityDate", parameterToString(*r.maxLastActivityDate, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.onlyProjectsWithExplicitMembership != nil {
		localVarQueryParams.Add("onlyProjectsWithExplicitMembership", parameterToString(*r.onlyProjectsWithExplicitMembership, ""))
	}
	if r.onlyArchivedProjects != nil {
		localVarQueryParams.Add("onlyArchivedProjects", parameterToString(*r.onlyArchivedProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.isReportDownload != nil {
		localVarQueryParams.Add("isReportDownload", parameterToString(*r.isReportDownload, ""))
	}
	if r.includeProjectUserInfo != nil {
		localVarQueryParams.Add("includeProjectUserInfo", parameterToString(*r.includeProjectUserInfo, ""))
	}
	if r.includeCustomFields != nil {
		localVarQueryParams.Add("includeCustomFields", parameterToString(*r.includeCustomFields, ""))
	}
	if r.includeCompletedStatus != nil {
		localVarQueryParams.Add("includeCompletedStatus", parameterToString(*r.includeCompletedStatus, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.hideObservedProjects != nil {
		localVarQueryParams.Add("hideObservedProjects", parameterToString(*r.hideObservedProjects, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsTags != nil {
		localVarQueryParams.Add("fields[tags]", parameterToString(*r.fieldsTags, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsProjectcategories != nil {
		localVarQueryParams.Add("fields[projectcategories]", parameterToString(*r.fieldsProjectcategories, "csv"))
	}
	if r.fieldsProjectUpdates != nil {
		localVarQueryParams.Add("fields[projectUpdates]", parameterToString(*r.fieldsProjectUpdates, "csv"))
	}
	if r.fieldsProjectBudgets != nil {
		localVarQueryParams.Add("fields[projectBudgets]", parameterToString(*r.fieldsProjectBudgets, "csv"))
	}
	if r.fieldsPortfolioColumns != nil {
		localVarQueryParams.Add("fields[portfolioColumns]", parameterToString(*r.fieldsPortfolioColumns, "csv"))
	}
	if r.fieldsPortfolioCards != nil {
		localVarQueryParams.Add("fields[portfolioCards]", parameterToString(*r.fieldsPortfolioCards, "csv"))
	}
	if r.fieldsPortfolioBoards != nil {
		localVarQueryParams.Add("fields[portfolioBoards]", parameterToString(*r.fieldsPortfolioBoards, "csv"))
	}
	if r.fieldsCustomfields != nil {
		localVarQueryParams.Add("fields[customfields]", parameterToString(*r.fieldsCustomfields, "csv"))
	}
	if r.fieldsCustomfieldProjects != nil {
		localVarQueryParams.Add("fields[customfieldProjects]", parameterToString(*r.fieldsCustomfieldProjects, "csv"))
	}
	if r.fieldsCompanies != nil {
		localVarQueryParams.Add("fields[companies]", parameterToString(*r.fieldsCompanies, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	projectId int32
}


func (r ApiGETProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest) Execute() (ProjectFeatureOrderResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsprojectIdFeatureorderJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsprojectIdFeatureorderJson Returns a project features order to display in tab
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId
 * @return ApiGETProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsprojectIdFeatureorderJson(ctx _context.Context, projectId int32) ApiGETProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest {
	return ApiGETProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return ProjectFeatureOrderResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsprojectIdFeatureorderJsonExecute(r ApiGETProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest) (ProjectFeatureOrderResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProjectFeatureOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsprojectIdFeatureorderJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/{projectId}/featureorder.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsprojectIdJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	projectId int32
	updatedAfter *time.Time
	searchTerm *string
	reportType *string
	reportFormat *string
	projectType *string
	projectStatuses *string
	orderMode *string
	orderBy *string
	minLastActivityDate *string
	maxLastActivityDate *string
	userId *int32
	projectHealths *int32
	pageSize *int32
	page *int32
	onlyStarredProjects *bool
	onlyProjectsWithExplicitMembership *bool
	onlyArchivedProjects *bool
	matchAllProjectTags *bool
	isReportDownload *bool
	includeProjectUserInfo *bool
	includeCustomFields *bool
	includeCompletedStatus *bool
	includeArchivedProjects *bool
	hideObservedProjects *bool
	projectTagIds *[]int32
	projectOwnerIds *[]int32
	projectIds *[]int32
	projectCompanyIds *[]int32
	projectCategoryIds *[]int32
	include *[]string
	fieldsUsers *[]string
	fieldsTags *[]string
	fieldsProjects *[]string
	fieldsProjectcategories *[]string
	fieldsProjectUpdates *[]string
	fieldsProjectBudgets *[]string
	fieldsPortfolioColumns *[]string
	fieldsPortfolioCards *[]string
	fieldsPortfolioBoards *[]string
	fieldsCustomfields *[]string
	fieldsCustomfieldProjects *[]string
	fieldsCompanies *[]string
}

func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) SearchTerm(searchTerm string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) ReportType(reportType string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.reportType = &reportType
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) ReportFormat(reportFormat string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.reportFormat = &reportFormat
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) ProjectType(projectType string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) ProjectStatuses(projectStatuses string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.projectStatuses = &projectStatuses
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) OrderMode(orderMode string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) OrderBy(orderBy string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) MinLastActivityDate(minLastActivityDate string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.minLastActivityDate = &minLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) MaxLastActivityDate(maxLastActivityDate string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.maxLastActivityDate = &maxLastActivityDate
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) UserId(userId int32) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.userId = &userId
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) ProjectHealths(projectHealths int32) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.projectHealths = &projectHealths
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) PageSize(pageSize int32) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) Page(page int32) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) OnlyProjectsWithExplicitMembership(onlyProjectsWithExplicitMembership bool) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.onlyProjectsWithExplicitMembership = &onlyProjectsWithExplicitMembership
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) OnlyArchivedProjects(onlyArchivedProjects bool) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.onlyArchivedProjects = &onlyArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) MatchAllProjectTags(matchAllProjectTags bool) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.matchAllProjectTags = &matchAllProjectTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) IsReportDownload(isReportDownload bool) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.isReportDownload = &isReportDownload
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) IncludeProjectUserInfo(includeProjectUserInfo bool) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.includeProjectUserInfo = &includeProjectUserInfo
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) IncludeCustomFields(includeCustomFields bool) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.includeCustomFields = &includeCustomFields
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) IncludeCompletedStatus(includeCompletedStatus bool) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.includeCompletedStatus = &includeCompletedStatus
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) HideObservedProjects(hideObservedProjects bool) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.hideObservedProjects = &hideObservedProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) ProjectTagIds(projectTagIds []int32) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.projectTagIds = &projectTagIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) ProjectOwnerIds(projectOwnerIds []int32) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) ProjectIds(projectIds []int32) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.projectIds = &projectIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) ProjectCompanyIds(projectCompanyIds []int32) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.projectCompanyIds = &projectCompanyIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) ProjectCategoryIds(projectCategoryIds []int32) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.projectCategoryIds = &projectCategoryIds
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) Include(include []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsTags(fieldsTags []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsTags = &fieldsTags
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsProjectcategories(fieldsProjectcategories []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsProjectcategories = &fieldsProjectcategories
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsProjectUpdates(fieldsProjectUpdates []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsProjectUpdates = &fieldsProjectUpdates
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsProjectBudgets(fieldsProjectBudgets []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsProjectBudgets = &fieldsProjectBudgets
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsPortfolioColumns(fieldsPortfolioColumns []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsPortfolioColumns = &fieldsPortfolioColumns
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsPortfolioCards(fieldsPortfolioCards []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsPortfolioCards = &fieldsPortfolioCards
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsPortfolioBoards(fieldsPortfolioBoards []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsPortfolioBoards = &fieldsPortfolioBoards
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsCustomfields(fieldsCustomfields []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsCustomfields = &fieldsCustomfields
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsCustomfieldProjects(fieldsCustomfieldProjects []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsCustomfieldProjects = &fieldsCustomfieldProjects
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) FieldsCompanies(fieldsCompanies []string) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	r.fieldsCompanies = &fieldsCompanies
	return r
}

func (r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) Execute() (ProjectSingleResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsprojectIdJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsprojectIdJson Returns a project
 * On this endpoint you can filter by project custom fields. The syntax for the
query parameter is the following:

    projectCustomField[id][op]=value

Where:
  - [id] is the custom field ID
  - [op] is the operator to apply when filtering, different operators are
    allowed according to the custom field type
  - [value] is the value to apply when filtering

For example, if I want to filter a dropdown custom field with ID 10 to only
return entries that have the value "Option1" we would do the following:

    projectCustomField[10][eq]=Option1

The allowed operators are:
  - like
  - not-like
  - eq
  - not
  - lt
  - gt
  - any
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId
 * @return ApiGETProjectsApiV3ProjectsprojectIdJsonRequest
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsprojectIdJson(ctx _context.Context, projectId int32) ApiGETProjectsApiV3ProjectsprojectIdJsonRequest {
	return ApiGETProjectsApiV3ProjectsprojectIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return ProjectSingleResponse
 */
func (a *ProjectsApiService) GETProjectsApiV3ProjectsprojectIdJsonExecute(r ApiGETProjectsApiV3ProjectsprojectIdJsonRequest) (ProjectSingleResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProjectSingleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsApiV3ProjectsprojectIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/{projectId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.reportType != nil {
		localVarQueryParams.Add("reportType", parameterToString(*r.reportType, ""))
	}
	if r.reportFormat != nil {
		localVarQueryParams.Add("reportFormat", parameterToString(*r.reportFormat, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.projectStatuses != nil {
		localVarQueryParams.Add("projectStatuses", parameterToString(*r.projectStatuses, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.minLastActivityDate != nil {
		localVarQueryParams.Add("minLastActivityDate", parameterToString(*r.minLastActivityDate, ""))
	}
	if r.maxLastActivityDate != nil {
		localVarQueryParams.Add("maxLastActivityDate", parameterToString(*r.maxLastActivityDate, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectHealths != nil {
		localVarQueryParams.Add("projectHealths", parameterToString(*r.projectHealths, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.onlyProjectsWithExplicitMembership != nil {
		localVarQueryParams.Add("onlyProjectsWithExplicitMembership", parameterToString(*r.onlyProjectsWithExplicitMembership, ""))
	}
	if r.onlyArchivedProjects != nil {
		localVarQueryParams.Add("onlyArchivedProjects", parameterToString(*r.onlyArchivedProjects, ""))
	}
	if r.matchAllProjectTags != nil {
		localVarQueryParams.Add("matchAllProjectTags", parameterToString(*r.matchAllProjectTags, ""))
	}
	if r.isReportDownload != nil {
		localVarQueryParams.Add("isReportDownload", parameterToString(*r.isReportDownload, ""))
	}
	if r.includeProjectUserInfo != nil {
		localVarQueryParams.Add("includeProjectUserInfo", parameterToString(*r.includeProjectUserInfo, ""))
	}
	if r.includeCustomFields != nil {
		localVarQueryParams.Add("includeCustomFields", parameterToString(*r.includeCustomFields, ""))
	}
	if r.includeCompletedStatus != nil {
		localVarQueryParams.Add("includeCompletedStatus", parameterToString(*r.includeCompletedStatus, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.hideObservedProjects != nil {
		localVarQueryParams.Add("hideObservedProjects", parameterToString(*r.hideObservedProjects, ""))
	}
	if r.projectTagIds != nil {
		localVarQueryParams.Add("projectTagIds", parameterToString(*r.projectTagIds, "csv"))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, "csv"))
	}
	if r.projectIds != nil {
		localVarQueryParams.Add("projectIds", parameterToString(*r.projectIds, "csv"))
	}
	if r.projectCompanyIds != nil {
		localVarQueryParams.Add("projectCompanyIds", parameterToString(*r.projectCompanyIds, "csv"))
	}
	if r.projectCategoryIds != nil {
		localVarQueryParams.Add("projectCategoryIds", parameterToString(*r.projectCategoryIds, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsTags != nil {
		localVarQueryParams.Add("fields[tags]", parameterToString(*r.fieldsTags, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsProjectcategories != nil {
		localVarQueryParams.Add("fields[projectcategories]", parameterToString(*r.fieldsProjectcategories, "csv"))
	}
	if r.fieldsProjectUpdates != nil {
		localVarQueryParams.Add("fields[projectUpdates]", parameterToString(*r.fieldsProjectUpdates, "csv"))
	}
	if r.fieldsProjectBudgets != nil {
		localVarQueryParams.Add("fields[projectBudgets]", parameterToString(*r.fieldsProjectBudgets, "csv"))
	}
	if r.fieldsPortfolioColumns != nil {
		localVarQueryParams.Add("fields[portfolioColumns]", parameterToString(*r.fieldsPortfolioColumns, "csv"))
	}
	if r.fieldsPortfolioCards != nil {
		localVarQueryParams.Add("fields[portfolioCards]", parameterToString(*r.fieldsPortfolioCards, "csv"))
	}
	if r.fieldsPortfolioBoards != nil {
		localVarQueryParams.Add("fields[portfolioBoards]", parameterToString(*r.fieldsPortfolioBoards, "csv"))
	}
	if r.fieldsCustomfields != nil {
		localVarQueryParams.Add("fields[customfields]", parameterToString(*r.fieldsCustomfields, "csv"))
	}
	if r.fieldsCustomfieldProjects != nil {
		localVarQueryParams.Add("fields[customfieldProjects]", parameterToString(*r.fieldsCustomfieldProjects, "csv"))
	}
	if r.fieldsCompanies != nil {
		localVarQueryParams.Add("fields[companies]", parameterToString(*r.fieldsCompanies, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTProjectsApiV3ProjectsFeatureorderJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	projectFeatureOrderDefaults *ProjectFeatureOrderDefaults
}

func (r ApiPUTProjectsApiV3ProjectsFeatureorderJsonRequest) ProjectFeatureOrderDefaults(projectFeatureOrderDefaults ProjectFeatureOrderDefaults) ApiPUTProjectsApiV3ProjectsFeatureorderJsonRequest {
	r.projectFeatureOrderDefaults = &projectFeatureOrderDefaults
	return r
}

func (r ApiPUTProjectsApiV3ProjectsFeatureorderJsonRequest) Execute() (ProjectFeatureOrderResponse, *_nethttp.Response, error) {
	return r.ApiService.PUTProjectsApiV3ProjectsFeatureorderJsonExecute(r)
}

/*
 * PUTProjectsApiV3ProjectsFeatureorderJson Sets the default features order to display in tab
 * Each field must have an index, from 0 to numFeatures -1
without repeated numbers to provide the order
to display the features
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPUTProjectsApiV3ProjectsFeatureorderJsonRequest
 */
func (a *ProjectsApiService) PUTProjectsApiV3ProjectsFeatureorderJson(ctx _context.Context) ApiPUTProjectsApiV3ProjectsFeatureorderJsonRequest {
	return ApiPUTProjectsApiV3ProjectsFeatureorderJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ProjectFeatureOrderResponse
 */
func (a *ProjectsApiService) PUTProjectsApiV3ProjectsFeatureorderJsonExecute(r ApiPUTProjectsApiV3ProjectsFeatureorderJsonRequest) (ProjectFeatureOrderResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProjectFeatureOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.PUTProjectsApiV3ProjectsFeatureorderJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/featureorder.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.projectFeatureOrderDefaults == nil {
		return localVarReturnValue, nil, reportError("projectFeatureOrderDefaults is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.projectFeatureOrderDefaults
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	projectId int32
	projectFeatureOrder *ProjectFeatureOrder
}

func (r ApiPUTProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest) ProjectFeatureOrder(projectFeatureOrder ProjectFeatureOrder) ApiPUTProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest {
	r.projectFeatureOrder = &projectFeatureOrder
	return r
}

func (r ApiPUTProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest) Execute() (ProjectFeatureOrderResponse, *_nethttp.Response, error) {
	return r.ApiService.PUTProjectsApiV3ProjectsprojectIdFeatureorderJsonExecute(r)
}

/*
 * PUTProjectsApiV3ProjectsprojectIdFeatureorderJson Sets the the features order to display in tab
 * Each field must have an index, from 0 to numFeatures -1
without repeated numbers to provide the order
to display the features
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId
 * @return ApiPUTProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest
 */
func (a *ProjectsApiService) PUTProjectsApiV3ProjectsprojectIdFeatureorderJson(ctx _context.Context, projectId int32) ApiPUTProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest {
	return ApiPUTProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return ProjectFeatureOrderResponse
 */
func (a *ProjectsApiService) PUTProjectsApiV3ProjectsprojectIdFeatureorderJsonExecute(r ApiPUTProjectsApiV3ProjectsprojectIdFeatureorderJsonRequest) (ProjectFeatureOrderResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProjectFeatureOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.PUTProjectsApiV3ProjectsprojectIdFeatureorderJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/{projectId}/featureorder.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.projectFeatureOrder == nil {
		return localVarReturnValue, nil, reportError("projectFeatureOrder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.projectFeatureOrder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
