/*
 * Teamwork Projects API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pmv1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ProjectsApiService ProjectsApi service
type ProjectsApiService service

type ApiDELETEProjectsIdJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	id string
}


func (r ApiDELETEProjectsIdJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.DELETEProjectsIdJsonExecute(r)
}

/*
 * DELETEProjectsIdJson Delete Project
 * Deletes a single project.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiDELETEProjectsIdJsonRequest
 */
func (a *ProjectsApiService) DELETEProjectsIdJson(ctx _context.Context, id string) ApiDELETEProjectsIdJsonRequest {
	return ApiDELETEProjectsIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *ProjectsApiService) DELETEProjectsIdJsonExecute(r ApiDELETEProjectsIdJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.DELETEProjectsIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETCompaniesIdProjectsJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	id string
	includePeople *bool
}

func (r ApiGETCompaniesIdProjectsJsonRequest) IncludePeople(includePeople bool) ApiGETCompaniesIdProjectsJsonRequest {
	r.includePeople = &includePeople
	return r
}

func (r ApiGETCompaniesIdProjectsJsonRequest) Execute() (InlineResponse20014, *_nethttp.Response, error) {
	return r.ApiService.GETCompaniesIdProjectsJsonExecute(r)
}

/*
 * GETCompaniesIdProjectsJson Retrieve Projects assigned to a specific Company
 * Returns a single project identified by its integer ID.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETCompaniesIdProjectsJsonRequest
 */
func (a *ProjectsApiService) GETCompaniesIdProjectsJson(ctx _context.Context, id string) ApiGETCompaniesIdProjectsJsonRequest {
	return ApiGETCompaniesIdProjectsJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20014
 */
func (a *ProjectsApiService) GETCompaniesIdProjectsJsonExecute(r ApiGETCompaniesIdProjectsJsonRequest) (InlineResponse20014, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20014
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETCompaniesIdProjectsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/companies/{id}/projects.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.includePeople != nil {
		localVarQueryParams.Add("includePeople", parameterToString(*r.includePeople, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsIdJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	id string
	includePeople *bool
	projectOwnerIds *string
	projectHealth *string
	includeProjectOwner *bool
	userId *string
}

func (r ApiGETProjectsIdJsonRequest) IncludePeople(includePeople bool) ApiGETProjectsIdJsonRequest {
	r.includePeople = &includePeople
	return r
}
func (r ApiGETProjectsIdJsonRequest) ProjectOwnerIds(projectOwnerIds string) ApiGETProjectsIdJsonRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsIdJsonRequest) ProjectHealth(projectHealth string) ApiGETProjectsIdJsonRequest {
	r.projectHealth = &projectHealth
	return r
}
func (r ApiGETProjectsIdJsonRequest) IncludeProjectOwner(includeProjectOwner bool) ApiGETProjectsIdJsonRequest {
	r.includeProjectOwner = &includeProjectOwner
	return r
}
func (r ApiGETProjectsIdJsonRequest) UserId(userId string) ApiGETProjectsIdJsonRequest {
	r.userId = &userId
	return r
}

func (r ApiGETProjectsIdJsonRequest) Execute() (InlineResponse20060, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsIdJsonExecute(r)
}

/*
 * GETProjectsIdJson Retrieve a Single Project
 * Returns a single project identified by its integer ID.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETProjectsIdJsonRequest
 */
func (a *ProjectsApiService) GETProjectsIdJson(ctx _context.Context, id string) ApiGETProjectsIdJsonRequest {
	return ApiGETProjectsIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20060
 */
func (a *ProjectsApiService) GETProjectsIdJsonExecute(r ApiGETProjectsIdJsonRequest) (InlineResponse20060, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20060
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.includePeople != nil {
		localVarQueryParams.Add("includePeople", parameterToString(*r.includePeople, ""))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, ""))
	}
	if r.projectHealth != nil {
		localVarQueryParams.Add("projectHealth", parameterToString(*r.projectHealth, ""))
	}
	if r.includeProjectOwner != nil {
		localVarQueryParams.Add("includeProjectOwner", parameterToString(*r.includeProjectOwner, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsIdRatesJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	id string
	page *int32
	pageSize *int32
}

func (r ApiGETProjectsIdRatesJsonRequest) Page(page int32) ApiGETProjectsIdRatesJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsIdRatesJsonRequest) PageSize(pageSize int32) ApiGETProjectsIdRatesJsonRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGETProjectsIdRatesJsonRequest) Execute() (InlineResponse20072, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsIdRatesJsonExecute(r)
}

/*
 * GETProjectsIdRatesJson Get Project Rates
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETProjectsIdRatesJsonRequest
 */
func (a *ProjectsApiService) GETProjectsIdRatesJson(ctx _context.Context, id string) ApiGETProjectsIdRatesJsonRequest {
	return ApiGETProjectsIdRatesJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20072
 */
func (a *ProjectsApiService) GETProjectsIdRatesJsonExecute(r ApiGETProjectsIdRatesJsonRequest) (InlineResponse20072, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20072
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsIdRatesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}/rates.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsIdStatsJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	id string
	responsiblePartyIds *string
	onlymyprojects *bool
	forStarredProjects *bool
	onlyMyEvents *bool
	getPermissions *bool
	eventsInNext *float32
}

func (r ApiGETProjectsIdStatsJsonRequest) ResponsiblePartyIds(responsiblePartyIds string) ApiGETProjectsIdStatsJsonRequest {
	r.responsiblePartyIds = &responsiblePartyIds
	return r
}
func (r ApiGETProjectsIdStatsJsonRequest) Onlymyprojects(onlymyprojects bool) ApiGETProjectsIdStatsJsonRequest {
	r.onlymyprojects = &onlymyprojects
	return r
}
func (r ApiGETProjectsIdStatsJsonRequest) ForStarredProjects(forStarredProjects bool) ApiGETProjectsIdStatsJsonRequest {
	r.forStarredProjects = &forStarredProjects
	return r
}
func (r ApiGETProjectsIdStatsJsonRequest) OnlyMyEvents(onlyMyEvents bool) ApiGETProjectsIdStatsJsonRequest {
	r.onlyMyEvents = &onlyMyEvents
	return r
}
func (r ApiGETProjectsIdStatsJsonRequest) GetPermissions(getPermissions bool) ApiGETProjectsIdStatsJsonRequest {
	r.getPermissions = &getPermissions
	return r
}
func (r ApiGETProjectsIdStatsJsonRequest) EventsInNext(eventsInNext float32) ApiGETProjectsIdStatsJsonRequest {
	r.eventsInNext = &eventsInNext
	return r
}

func (r ApiGETProjectsIdStatsJsonRequest) Execute() (InlineResponse20075, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsIdStatsJsonExecute(r)
}

/*
 * GETProjectsIdStatsJson Get Project Stats
 * This returns all stats for that given project. Tasks, milestones etc. See response below. 

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETProjectsIdStatsJsonRequest
 */
func (a *ProjectsApiService) GETProjectsIdStatsJson(ctx _context.Context, id string) ApiGETProjectsIdStatsJsonRequest {
	return ApiGETProjectsIdStatsJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20075
 */
func (a *ProjectsApiService) GETProjectsIdStatsJsonExecute(r ApiGETProjectsIdStatsJsonRequest) (InlineResponse20075, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20075
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsIdStatsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}/stats.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.responsiblePartyIds != nil {
		localVarQueryParams.Add("responsible-party-ids", parameterToString(*r.responsiblePartyIds, ""))
	}
	if r.onlymyprojects != nil {
		localVarQueryParams.Add("onlymyprojects", parameterToString(*r.onlymyprojects, ""))
	}
	if r.forStarredProjects != nil {
		localVarQueryParams.Add("forStarredProjects", parameterToString(*r.forStarredProjects, ""))
	}
	if r.onlyMyEvents != nil {
		localVarQueryParams.Add("onlyMyEvents", parameterToString(*r.onlyMyEvents, ""))
	}
	if r.getPermissions != nil {
		localVarQueryParams.Add("getPermissions", parameterToString(*r.getPermissions, ""))
	}
	if r.eventsInNext != nil {
		localVarQueryParams.Add("eventsInNext", parameterToString(*r.eventsInNext, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	status *string
	updatedAfterDate *string
	orderby *string
	createdAfterDate *string
	createdAfterTime *string
	catId *int32
	includePeople *bool
	includeProjectOwner *bool
	page *string
	pageSize *float32
	orderMode *string
	onlyStarredProjects *bool
	companyId *string
	projectOwnerIds *string
	searchTerm *string
	getDeleted *bool
	includeTags *bool
	userId *string
	updatedAfterDateTime *string
}

func (r ApiGETProjectsJsonRequest) Status(status string) ApiGETProjectsJsonRequest {
	r.status = &status
	return r
}
func (r ApiGETProjectsJsonRequest) UpdatedAfterDate(updatedAfterDate string) ApiGETProjectsJsonRequest {
	r.updatedAfterDate = &updatedAfterDate
	return r
}
func (r ApiGETProjectsJsonRequest) Orderby(orderby string) ApiGETProjectsJsonRequest {
	r.orderby = &orderby
	return r
}
func (r ApiGETProjectsJsonRequest) CreatedAfterDate(createdAfterDate string) ApiGETProjectsJsonRequest {
	r.createdAfterDate = &createdAfterDate
	return r
}
func (r ApiGETProjectsJsonRequest) CreatedAfterTime(createdAfterTime string) ApiGETProjectsJsonRequest {
	r.createdAfterTime = &createdAfterTime
	return r
}
func (r ApiGETProjectsJsonRequest) CatId(catId int32) ApiGETProjectsJsonRequest {
	r.catId = &catId
	return r
}
func (r ApiGETProjectsJsonRequest) IncludePeople(includePeople bool) ApiGETProjectsJsonRequest {
	r.includePeople = &includePeople
	return r
}
func (r ApiGETProjectsJsonRequest) IncludeProjectOwner(includeProjectOwner bool) ApiGETProjectsJsonRequest {
	r.includeProjectOwner = &includeProjectOwner
	return r
}
func (r ApiGETProjectsJsonRequest) Page(page string) ApiGETProjectsJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsJsonRequest) PageSize(pageSize float32) ApiGETProjectsJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsJsonRequest) OrderMode(orderMode string) ApiGETProjectsJsonRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsJsonRequest) OnlyStarredProjects(onlyStarredProjects bool) ApiGETProjectsJsonRequest {
	r.onlyStarredProjects = &onlyStarredProjects
	return r
}
func (r ApiGETProjectsJsonRequest) CompanyId(companyId string) ApiGETProjectsJsonRequest {
	r.companyId = &companyId
	return r
}
func (r ApiGETProjectsJsonRequest) ProjectOwnerIds(projectOwnerIds string) ApiGETProjectsJsonRequest {
	r.projectOwnerIds = &projectOwnerIds
	return r
}
func (r ApiGETProjectsJsonRequest) SearchTerm(searchTerm string) ApiGETProjectsJsonRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsJsonRequest) GetDeleted(getDeleted bool) ApiGETProjectsJsonRequest {
	r.getDeleted = &getDeleted
	return r
}
func (r ApiGETProjectsJsonRequest) IncludeTags(includeTags bool) ApiGETProjectsJsonRequest {
	r.includeTags = &includeTags
	return r
}
func (r ApiGETProjectsJsonRequest) UserId(userId string) ApiGETProjectsJsonRequest {
	r.userId = &userId
	return r
}
func (r ApiGETProjectsJsonRequest) UpdatedAfterDateTime(updatedAfterDateTime string) ApiGETProjectsJsonRequest {
	r.updatedAfterDateTime = &updatedAfterDateTime
	return r
}

func (r ApiGETProjectsJsonRequest) Execute() (InlineResponse20053, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsJsonExecute(r)
}

/*
 * GETProjectsJson Retrieve All Projects
 * Retrieves all accessible projects. Default returns your active projects.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsJsonRequest
 */
func (a *ProjectsApiService) GETProjectsJson(ctx _context.Context) ApiGETProjectsJsonRequest {
	return ApiGETProjectsJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20053
 */
func (a *ProjectsApiService) GETProjectsJsonExecute(r ApiGETProjectsJsonRequest) (InlineResponse20053, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20053
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.updatedAfterDate != nil {
		localVarQueryParams.Add("updatedAfterDate", parameterToString(*r.updatedAfterDate, ""))
	}
	if r.orderby != nil {
		localVarQueryParams.Add("orderby", parameterToString(*r.orderby, ""))
	}
	if r.createdAfterDate != nil {
		localVarQueryParams.Add("createdAfterDate", parameterToString(*r.createdAfterDate, ""))
	}
	if r.createdAfterTime != nil {
		localVarQueryParams.Add("createdAfterTime", parameterToString(*r.createdAfterTime, ""))
	}
	if r.catId != nil {
		localVarQueryParams.Add("catId", parameterToString(*r.catId, ""))
	}
	if r.includePeople != nil {
		localVarQueryParams.Add("includePeople", parameterToString(*r.includePeople, ""))
	}
	if r.includeProjectOwner != nil {
		localVarQueryParams.Add("includeProjectOwner", parameterToString(*r.includeProjectOwner, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.onlyStarredProjects != nil {
		localVarQueryParams.Add("onlyStarredProjects", parameterToString(*r.onlyStarredProjects, ""))
	}
	if r.companyId != nil {
		localVarQueryParams.Add("companyId", parameterToString(*r.companyId, ""))
	}
	if r.projectOwnerIds != nil {
		localVarQueryParams.Add("projectOwnerIds", parameterToString(*r.projectOwnerIds, ""))
	}
	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.getDeleted != nil {
		localVarQueryParams.Add("getDeleted", parameterToString(*r.getDeleted, ""))
	}
	if r.includeTags != nil {
		localVarQueryParams.Add("includeTags", parameterToString(*r.includeTags, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.updatedAfterDateTime != nil {
		localVarQueryParams.Add("updatedAfterDateTime", parameterToString(*r.updatedAfterDateTime, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsStarredJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
}


func (r ApiGETProjectsStarredJsonRequest) Execute() (InlineResponse20014, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsStarredJsonExecute(r)
}

/*
 * GETProjectsStarredJson Retrieve your Starred Projects
 * Surprisingly, this will retrieve all of your projects, which have been starred!

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsStarredJsonRequest
 */
func (a *ProjectsApiService) GETProjectsStarredJson(ctx _context.Context) ApiGETProjectsStarredJsonRequest {
	return ApiGETProjectsStarredJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20014
 */
func (a *ProjectsApiService) GETProjectsStarredJsonExecute(r ApiGETProjectsStarredJsonRequest) (InlineResponse20014, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20014
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.GETProjectsStarredJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/starred.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTProjectsIdRatesJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	id string
	body *InlineObject70
}

func (r ApiPOSTProjectsIdRatesJsonRequest) Body(body InlineObject70) ApiPOSTProjectsIdRatesJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTProjectsIdRatesJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.POSTProjectsIdRatesJsonExecute(r)
}

/*
 * POSTProjectsIdRatesJson Set Project Rates
 * This allows you to set Rates for people on a Project.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPOSTProjectsIdRatesJsonRequest
 */
func (a *ProjectsApiService) POSTProjectsIdRatesJson(ctx _context.Context, id string) ApiPOSTProjectsIdRatesJsonRequest {
	return ApiPOSTProjectsIdRatesJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *ProjectsApiService) POSTProjectsIdRatesJsonExecute(r ApiPOSTProjectsIdRatesJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.POSTProjectsIdRatesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}/rates.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTProjectsJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	body *InlineObject50
}

func (r ApiPOSTProjectsJsonRequest) Body(body InlineObject50) ApiPOSTProjectsJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTProjectsJsonRequest) Execute() (InlineResponse201, *_nethttp.Response, error) {
	return r.ApiService.POSTProjectsJsonExecute(r)
}

/*
 * POSTProjectsJson Create Project
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPOSTProjectsJsonRequest
 */
func (a *ProjectsApiService) POSTProjectsJson(ctx _context.Context) ApiPOSTProjectsJsonRequest {
	return ApiPOSTProjectsJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse201
 */
func (a *ProjectsApiService) POSTProjectsJsonExecute(r ApiPOSTProjectsJsonRequest) (InlineResponse201, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse201
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.POSTProjectsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTProjectsIdJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	id string
	body *InlineObject55
}

func (r ApiPUTProjectsIdJsonRequest) Body(body InlineObject55) ApiPUTProjectsIdJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTProjectsIdJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.PUTProjectsIdJsonExecute(r)
}

/*
 * PUTProjectsIdJson Update Project
 * Modifies a single project.

Use this endpoint to: 
- **Enable and Disable Projects Features**: All features in Projects such as Tasks, Messages, Time, Billing and more can be enabled and disabled via the API.

```
{
  "project": {
    "use-tasks": "1",
    "use-messages": "1",
    "use-time": "1",
    "use-riskregister": "1",
    "use-billing": "1",
    "use-milestones": "1",
    "use-files": "1",
    "use-notebook": "1",
    "use-links": "1"
  }
}
```

- **Set/Remove a Project Owner**: This allows you to set a project owner by using in the project id in the path and sending in the id of the owner in the body of the request.

Please note:

If the project is inside a portfolio board, you will also recieve the column and the card that project is associated with. This affects the board because you can filter by project owner.

Your response will look like this:

```
{
    "linkedColumnId": "12345",
    "STATUS": "OK",
    "linkedCardId": "12345"
}
```

- **Update a Project Status**: Modifies a single project status. Inactive to archive project, active to unarchive project.
```
{
  "project": {
    "status": "inactive"
  }
}
```
- **Add or update the Project logo**: This will add an image to become a Project logo. It will replace the existing logo if there is one in place. First, use the file upload API call to upload a file and receive back a file reference string. Then, perform the following to update a project.
```
{
    "project": {
        "logoPendingFileRef": "{your_uploaded_file_reference}"
    }
}
```
---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPUTProjectsIdJsonRequest
 */
func (a *ProjectsApiService) PUTProjectsIdJson(ctx _context.Context, id string) ApiPUTProjectsIdJsonRequest {
	return ApiPUTProjectsIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *ProjectsApiService) PUTProjectsIdJsonExecute(r ApiPUTProjectsIdJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.PUTProjectsIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTProjectsIdStarJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	id string
}


func (r ApiPUTProjectsIdStarJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.PUTProjectsIdStarJsonExecute(r)
}

/*
 * PUTProjectsIdStarJson Star a Project
 * Adds a project to your list of favourite projects.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPUTProjectsIdStarJsonRequest
 */
func (a *ProjectsApiService) PUTProjectsIdStarJson(ctx _context.Context, id string) ApiPUTProjectsIdStarJsonRequest {
	return ApiPUTProjectsIdStarJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *ProjectsApiService) PUTProjectsIdStarJsonExecute(r ApiPUTProjectsIdStarJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.PUTProjectsIdStarJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}/star.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTProjectsIdUnstarJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectsApiService
	id string
	body *InlineObject76
}

func (r ApiPUTProjectsIdUnstarJsonRequest) Body(body InlineObject76) ApiPUTProjectsIdUnstarJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTProjectsIdUnstarJsonRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.PUTProjectsIdUnstarJsonExecute(r)
}

/*
 * PUTProjectsIdUnstarJson Un-star a Project
 * Removes a project to your list of favourite projects.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPUTProjectsIdUnstarJsonRequest
 */
func (a *ProjectsApiService) PUTProjectsIdUnstarJson(ctx _context.Context, id string) ApiPUTProjectsIdUnstarJsonRequest {
	return ApiPUTProjectsIdUnstarJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *ProjectsApiService) PUTProjectsIdUnstarJsonExecute(r ApiPUTProjectsIdUnstarJsonRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsApiService.PUTProjectsIdUnstarJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}/unstar.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
