/*
 * Teamwork Projects API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pmv1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ProjectUpdatesApiService ProjectUpdatesApi service
type ProjectUpdatesApiService service

type ApiDELETEProjectsUpdatesUpdateIdJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectUpdatesApiService
	updateId string
}


func (r ApiDELETEProjectsUpdatesUpdateIdJsonRequest) Execute() (InlineResponse20059, *_nethttp.Response, error) {
	return r.ApiService.DELETEProjectsUpdatesUpdateIdJsonExecute(r)
}

/*
 * DELETEProjectsUpdatesUpdateIdJson Delete a Project Update
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param updateId
 * @return ApiDELETEProjectsUpdatesUpdateIdJsonRequest
 */
func (a *ProjectUpdatesApiService) DELETEProjectsUpdatesUpdateIdJson(ctx _context.Context, updateId string) ApiDELETEProjectsUpdatesUpdateIdJsonRequest {
	return ApiDELETEProjectsUpdatesUpdateIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		updateId: updateId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20059
 */
func (a *ProjectUpdatesApiService) DELETEProjectsUpdatesUpdateIdJsonExecute(r ApiDELETEProjectsUpdatesUpdateIdJsonRequest) (InlineResponse20059, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20059
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectUpdatesApiService.DELETEProjectsUpdatesUpdateIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/updates/{updateId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"updateId"+"}", _neturl.PathEscape(parameterToString(r.updateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsProjIdUpdateJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectUpdatesApiService
	projId string
}


func (r ApiGETProjectsProjIdUpdateJsonRequest) Execute() (InlineResponse20080, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsProjIdUpdateJsonExecute(r)
}

/*
 * GETProjectsProjIdUpdateJson Get most recent Update
 * This will return the most recent update along with the project health. 


---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projId
 * @return ApiGETProjectsProjIdUpdateJsonRequest
 */
func (a *ProjectUpdatesApiService) GETProjectsProjIdUpdateJson(ctx _context.Context, projId string) ApiGETProjectsProjIdUpdateJsonRequest {
	return ApiGETProjectsProjIdUpdateJsonRequest{
		ApiService: a,
		ctx: ctx,
		projId: projId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20080
 */
func (a *ProjectUpdatesApiService) GETProjectsProjIdUpdateJsonExecute(r ApiGETProjectsProjIdUpdateJsonRequest) (InlineResponse20080, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20080
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectUpdatesApiService.GETProjectsProjIdUpdateJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{projId}/update.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projId"+"}", _neturl.PathEscape(parameterToString(r.projId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsProjIdUpdatesJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectUpdatesApiService
	projId string
}


func (r ApiGETProjectsProjIdUpdatesJsonRequest) Execute() (InlineResponse20080, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsProjIdUpdatesJsonExecute(r)
}

/*
 * GETProjectsProjIdUpdatesJson Get Project Updates
 * Returns all project updates.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projId
 * @return ApiGETProjectsProjIdUpdatesJsonRequest
 */
func (a *ProjectUpdatesApiService) GETProjectsProjIdUpdatesJson(ctx _context.Context, projId string) ApiGETProjectsProjIdUpdatesJsonRequest {
	return ApiGETProjectsProjIdUpdatesJsonRequest{
		ApiService: a,
		ctx: ctx,
		projId: projId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20080
 */
func (a *ProjectUpdatesApiService) GETProjectsProjIdUpdatesJsonExecute(r ApiGETProjectsProjIdUpdatesJsonRequest) (InlineResponse20080, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20080
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectUpdatesApiService.GETProjectsProjIdUpdatesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{projId}/updates.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projId"+"}", _neturl.PathEscape(parameterToString(r.projId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTProjectsProjIdUpdateJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectUpdatesApiService
	projId string
	body *InlineObject78
}

func (r ApiPOSTProjectsProjIdUpdateJsonRequest) Body(body InlineObject78) ApiPOSTProjectsProjIdUpdateJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTProjectsProjIdUpdateJsonRequest) Execute() (InlineResponse20059, *_nethttp.Response, error) {
	return r.ApiService.POSTProjectsProjIdUpdateJsonExecute(r)
}

/*
 * POSTProjectsProjIdUpdateJson Create a Project Update
 * To add a project update via the api, call this endpoint and pass in the update and health in the body of the request.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projId
 * @return ApiPOSTProjectsProjIdUpdateJsonRequest
 */
func (a *ProjectUpdatesApiService) POSTProjectsProjIdUpdateJson(ctx _context.Context, projId string) ApiPOSTProjectsProjIdUpdateJsonRequest {
	return ApiPOSTProjectsProjIdUpdateJsonRequest{
		ApiService: a,
		ctx: ctx,
		projId: projId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20059
 */
func (a *ProjectUpdatesApiService) POSTProjectsProjIdUpdateJsonExecute(r ApiPOSTProjectsProjIdUpdateJsonRequest) (InlineResponse20059, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20059
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectUpdatesApiService.POSTProjectsProjIdUpdateJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{projId}/update.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projId"+"}", _neturl.PathEscape(parameterToString(r.projId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTProjectsProjIdUpdateRequestJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectUpdatesApiService
	projId string
	body *InlineObject79
}

func (r ApiPUTProjectsProjIdUpdateRequestJsonRequest) Body(body InlineObject79) ApiPUTProjectsProjIdUpdateRequestJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTProjectsProjIdUpdateRequestJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.PUTProjectsProjIdUpdateRequestJsonExecute(r)
}

/*
 * PUTProjectsProjIdUpdateRequestJson Requesting a Project Update from a Project Owner
 * If you have a project owner set, you can request an update from them. This will notify them that you are looking for an update. From there, the project owner can go in and create a project update.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projId
 * @return ApiPUTProjectsProjIdUpdateRequestJsonRequest
 */
func (a *ProjectUpdatesApiService) PUTProjectsProjIdUpdateRequestJson(ctx _context.Context, projId string) ApiPUTProjectsProjIdUpdateRequestJsonRequest {
	return ApiPUTProjectsProjIdUpdateRequestJsonRequest{
		ApiService: a,
		ctx: ctx,
		projId: projId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *ProjectUpdatesApiService) PUTProjectsProjIdUpdateRequestJsonExecute(r ApiPUTProjectsProjIdUpdateRequestJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectUpdatesApiService.PUTProjectsProjIdUpdateRequestJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{projId}/update/request.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projId"+"}", _neturl.PathEscape(parameterToString(r.projId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v InlineResponse422
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTProjectsUpdatesUpdateIdJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectUpdatesApiService
	updateId string
	body *InlineObject53
}

func (r ApiPUTProjectsUpdatesUpdateIdJsonRequest) Body(body InlineObject53) ApiPUTProjectsUpdatesUpdateIdJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTProjectsUpdatesUpdateIdJsonRequest) Execute() (InlineResponse20059, *_nethttp.Response, error) {
	return r.ApiService.PUTProjectsUpdatesUpdateIdJsonExecute(r)
}

/*
 * PUTProjectsUpdatesUpdateIdJson Modify a Project Update
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param updateId
 * @return ApiPUTProjectsUpdatesUpdateIdJsonRequest
 */
func (a *ProjectUpdatesApiService) PUTProjectsUpdatesUpdateIdJson(ctx _context.Context, updateId string) ApiPUTProjectsUpdatesUpdateIdJsonRequest {
	return ApiPUTProjectsUpdatesUpdateIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		updateId: updateId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20059
 */
func (a *ProjectUpdatesApiService) PUTProjectsUpdatesUpdateIdJsonExecute(r ApiPUTProjectsUpdatesUpdateIdJsonRequest) (InlineResponse20059, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20059
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectUpdatesApiService.PUTProjectsUpdatesUpdateIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/updates/{updateId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"updateId"+"}", _neturl.PathEscape(parameterToString(r.updateId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
