/*
 * Teamwork Projects API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pmv1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ProjectOwnerApiService ProjectOwnerApi service
type ProjectOwnerApiService service

type ApiGETYoursiteProjectsJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectOwnerApiService
	includeProjectOwner *bool
}

func (r ApiGETYoursiteProjectsJsonRequest) IncludeProjectOwner(includeProjectOwner bool) ApiGETYoursiteProjectsJsonRequest {
	r.includeProjectOwner = &includeProjectOwner
	return r
}

func (r ApiGETYoursiteProjectsJsonRequest) Execute() (InlineResponse200121, *_nethttp.Response, error) {
	return r.ApiService.GETYoursiteProjectsJsonExecute(r)
}

/*
 * GETYoursiteProjectsJson Get Project Owner
 * Project owner can be returned by adding this parameter to the projects endpoint. You can add it to the get all projects call or to the projects/{projId}.json call.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETYoursiteProjectsJsonRequest
 */
func (a *ProjectOwnerApiService) GETYoursiteProjectsJson(ctx _context.Context) ApiGETYoursiteProjectsJsonRequest {
	return ApiGETYoursiteProjectsJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200121
 */
func (a *ProjectOwnerApiService) GETYoursiteProjectsJsonExecute(r ApiGETYoursiteProjectsJsonRequest) (InlineResponse200121, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200121
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectOwnerApiService.GETYoursiteProjectsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/yoursite/projects.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.includeProjectOwner == nil {
		return localVarReturnValue, nil, reportError("includeProjectOwner is required and must be specified")
	}

	localVarQueryParams.Add("includeProjectOwner", parameterToString(*r.includeProjectOwner, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTYoursiteProjectsProjIdJsonRequest struct {
	ctx _context.Context
	ApiService *ProjectOwnerApiService
	projId string
	body *InlineObject109
}

func (r ApiPUTYoursiteProjectsProjIdJsonRequest) Body(body InlineObject109) ApiPUTYoursiteProjectsProjIdJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTYoursiteProjectsProjIdJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.PUTYoursiteProjectsProjIdJsonExecute(r)
}

/*
 * PUTYoursiteProjectsProjIdJson Setting a Project Owner
 * This call allows you to set a project owner by using in the project id in the path and sending in the id of the owner in the body of the request.

This call can be used when changing a project owner.

<h4>Please note</h4>

If the project is inside a portfolio board, you will also recieve the column and the card that project is associated with. This affects the board because you can filter by project owner. 

Your response will look like this: 
```
{
    "linkedColumnId": "12345",
    "STATUS": "OK",
    "linkedCardId": "12345"
}
```

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projId
 * @return ApiPUTYoursiteProjectsProjIdJsonRequest
 */
func (a *ProjectOwnerApiService) PUTYoursiteProjectsProjIdJson(ctx _context.Context, projId string) ApiPUTYoursiteProjectsProjIdJsonRequest {
	return ApiPUTYoursiteProjectsProjIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		projId: projId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *ProjectOwnerApiService) PUTYoursiteProjectsProjIdJsonExecute(r ApiPUTYoursiteProjectsProjIdJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectOwnerApiService.PUTYoursiteProjectsProjIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/yoursite/projects/{projId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projId"+"}", _neturl.PathEscape(parameterToString(r.projId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
