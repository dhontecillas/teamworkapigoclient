/*
 * Teamwork.com Projects API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 3.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package projv3

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// FilesApiService FilesApi service
type FilesApiService service

type ApiDELETEProjectsApiV3FilesfileIdJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
	fileId int32
}


func (r ApiDELETEProjectsApiV3FilesfileIdJsonRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DELETEProjectsApiV3FilesfileIdJsonExecute(r)
}

/*
 * DELETEProjectsApiV3FilesfileIdJson Delete an existing file and it's versions.
 * Delete an existing file including all the file versions.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param fileId
 * @return ApiDELETEProjectsApiV3FilesfileIdJsonRequest
 */
func (a *FilesApiService) DELETEProjectsApiV3FilesfileIdJson(ctx _context.Context, fileId int32) ApiDELETEProjectsApiV3FilesfileIdJsonRequest {
	return ApiDELETEProjectsApiV3FilesfileIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

/*
 * Execute executes the request
 */
func (a *FilesApiService) DELETEProjectsApiV3FilesfileIdJsonExecute(r ApiDELETEProjectsApiV3FilesfileIdJsonRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.DELETEProjectsApiV3FilesfileIdJson")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/files/{fileId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", _neturl.PathEscape(parameterToString(r.fileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3FilesAvailableJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
}


func (r ApiGETProjectsApiV3FilesAvailableJsonRequest) Execute() (FileAvailableResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3FilesAvailableJsonExecute(r)
}

/*
 * GETProjectsApiV3FilesAvailableJson Retrieves available space on account
 * Retrieves the available space after calculating all stored file sizes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3FilesAvailableJsonRequest
 */
func (a *FilesApiService) GETProjectsApiV3FilesAvailableJson(ctx _context.Context) ApiGETProjectsApiV3FilesAvailableJsonRequest {
	return ApiGETProjectsApiV3FilesAvailableJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return FileAvailableResponse
 */
func (a *FilesApiService) GETProjectsApiV3FilesAvailableJsonExecute(r ApiGETProjectsApiV3FilesAvailableJsonRequest) (FileAvailableResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileAvailableResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.GETProjectsApiV3FilesAvailableJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/files/available.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3FilesChangesJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
	updatedAfterDateTime *time.Time
	updatedAfter *time.Time
	pageSize *int32
	includeParentId *bool
}

func (r ApiGETProjectsApiV3FilesChangesJsonRequest) UpdatedAfterDateTime(updatedAfterDateTime time.Time) ApiGETProjectsApiV3FilesChangesJsonRequest {
	r.updatedAfterDateTime = &updatedAfterDateTime
	return r
}
func (r ApiGETProjectsApiV3FilesChangesJsonRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3FilesChangesJsonRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3FilesChangesJsonRequest) PageSize(pageSize int32) ApiGETProjectsApiV3FilesChangesJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3FilesChangesJsonRequest) IncludeParentId(includeParentId bool) ApiGETProjectsApiV3FilesChangesJsonRequest {
	r.includeParentId = &includeParentId
	return r
}

func (r ApiGETProjectsApiV3FilesChangesJsonRequest) Execute() (ChangeChangesResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3FilesChangesJsonExecute(r)
}

/*
 * GETProjectsApiV3FilesChangesJson Get all recently changed files.
 * Retrieves all recently changed files sorted by lastUpdateDateTime Descending
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3FilesChangesJsonRequest
 */
func (a *FilesApiService) GETProjectsApiV3FilesChangesJson(ctx _context.Context) ApiGETProjectsApiV3FilesChangesJsonRequest {
	return ApiGETProjectsApiV3FilesChangesJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ChangeChangesResponse
 */
func (a *FilesApiService) GETProjectsApiV3FilesChangesJsonExecute(r ApiGETProjectsApiV3FilesChangesJsonRequest) (ChangeChangesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ChangeChangesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.GETProjectsApiV3FilesChangesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/files/changes.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.updatedAfterDateTime != nil {
		localVarQueryParams.Add("updatedAfterDateTime", parameterToString(*r.updatedAfterDateTime, ""))
	}
	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.includeParentId != nil {
		localVarQueryParams.Add("includeParentId", parameterToString(*r.includeParentId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3FilesJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
	uploadedStartDate *string
	uploadedEndDate *string
	updatedAfterDate *time.Time
	updatedAfter *time.Time
	status *string
	searchTerm *string
	projectType *string
	orderMode *string
	orderBy *string
	versionId *int32
	version *int32
	taskId *int32
	projectId *int32
	pageSize *int32
	page *int32
	id *int32
	categoryId *int32
	skipInternalFiles *bool
	skipExternalFiles *bool
	showDeleted *bool
	searchAllFields *bool
	matchAllTags *bool
	lockedOnly *bool
	getVersions *bool
	getVersionReactions *bool
	getRelatedItems *bool
	getReactions *bool
	getLikes *bool
	getComments *bool
	fromDocumentEditor *bool
	versionIds *[]int32
	userIds *[]int32
	tagIds *[]int32
	include *[]string
	fieldsUsers *[]string
	fieldsTasks *[]string
	fieldsTags *[]string
	fieldsProjects *[]string
	fieldsMessages *[]string
	fieldsFileCategories *[]string
	fieldsComments *[]string
}

func (r ApiGETProjectsApiV3FilesJsonRequest) UploadedStartDate(uploadedStartDate string) ApiGETProjectsApiV3FilesJsonRequest {
	r.uploadedStartDate = &uploadedStartDate
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) UploadedEndDate(uploadedEndDate string) ApiGETProjectsApiV3FilesJsonRequest {
	r.uploadedEndDate = &uploadedEndDate
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) UpdatedAfterDate(updatedAfterDate time.Time) ApiGETProjectsApiV3FilesJsonRequest {
	r.updatedAfterDate = &updatedAfterDate
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3FilesJsonRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) Status(status string) ApiGETProjectsApiV3FilesJsonRequest {
	r.status = &status
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) SearchTerm(searchTerm string) ApiGETProjectsApiV3FilesJsonRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) ProjectType(projectType string) ApiGETProjectsApiV3FilesJsonRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) OrderMode(orderMode string) ApiGETProjectsApiV3FilesJsonRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) OrderBy(orderBy string) ApiGETProjectsApiV3FilesJsonRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) VersionId(versionId int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.versionId = &versionId
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) Version(version int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.version = &version
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) TaskId(taskId int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.taskId = &taskId
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) ProjectId(projectId int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.projectId = &projectId
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) PageSize(pageSize int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) Page(page int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) Id(id int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.id = &id
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) CategoryId(categoryId int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.categoryId = &categoryId
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) SkipInternalFiles(skipInternalFiles bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.skipInternalFiles = &skipInternalFiles
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) SkipExternalFiles(skipExternalFiles bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.skipExternalFiles = &skipExternalFiles
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) ShowDeleted(showDeleted bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.showDeleted = &showDeleted
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) SearchAllFields(searchAllFields bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.searchAllFields = &searchAllFields
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) MatchAllTags(matchAllTags bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.matchAllTags = &matchAllTags
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) LockedOnly(lockedOnly bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.lockedOnly = &lockedOnly
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) GetVersions(getVersions bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.getVersions = &getVersions
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) GetVersionReactions(getVersionReactions bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.getVersionReactions = &getVersionReactions
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) GetRelatedItems(getRelatedItems bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.getRelatedItems = &getRelatedItems
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) GetReactions(getReactions bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.getReactions = &getReactions
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) GetLikes(getLikes bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.getLikes = &getLikes
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) GetComments(getComments bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.getComments = &getComments
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) FromDocumentEditor(fromDocumentEditor bool) ApiGETProjectsApiV3FilesJsonRequest {
	r.fromDocumentEditor = &fromDocumentEditor
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) VersionIds(versionIds []int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.versionIds = &versionIds
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) UserIds(userIds []int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.userIds = &userIds
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) TagIds(tagIds []int32) ApiGETProjectsApiV3FilesJsonRequest {
	r.tagIds = &tagIds
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) Include(include []string) ApiGETProjectsApiV3FilesJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3FilesJsonRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) FieldsTasks(fieldsTasks []string) ApiGETProjectsApiV3FilesJsonRequest {
	r.fieldsTasks = &fieldsTasks
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) FieldsTags(fieldsTags []string) ApiGETProjectsApiV3FilesJsonRequest {
	r.fieldsTags = &fieldsTags
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3FilesJsonRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) FieldsMessages(fieldsMessages []string) ApiGETProjectsApiV3FilesJsonRequest {
	r.fieldsMessages = &fieldsMessages
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) FieldsFileCategories(fieldsFileCategories []string) ApiGETProjectsApiV3FilesJsonRequest {
	r.fieldsFileCategories = &fieldsFileCategories
	return r
}
func (r ApiGETProjectsApiV3FilesJsonRequest) FieldsComments(fieldsComments []string) ApiGETProjectsApiV3FilesJsonRequest {
	r.fieldsComments = &fieldsComments
	return r
}

func (r ApiGETProjectsApiV3FilesJsonRequest) Execute() (FileProjectFilesResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3FilesJsonExecute(r)
}

/*
 * GETProjectsApiV3FilesJson Get a list of files.
 * Return all files for the provided filters.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3FilesJsonRequest
 */
func (a *FilesApiService) GETProjectsApiV3FilesJson(ctx _context.Context) ApiGETProjectsApiV3FilesJsonRequest {
	return ApiGETProjectsApiV3FilesJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return FileProjectFilesResponse
 */
func (a *FilesApiService) GETProjectsApiV3FilesJsonExecute(r ApiGETProjectsApiV3FilesJsonRequest) (FileProjectFilesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileProjectFilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.GETProjectsApiV3FilesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/files.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.uploadedStartDate != nil {
		localVarQueryParams.Add("uploadedStartDate", parameterToString(*r.uploadedStartDate, ""))
	}
	if r.uploadedEndDate != nil {
		localVarQueryParams.Add("uploadedEndDate", parameterToString(*r.uploadedEndDate, ""))
	}
	if r.updatedAfterDate != nil {
		localVarQueryParams.Add("updatedAfterDate", parameterToString(*r.updatedAfterDate, ""))
	}
	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.versionId != nil {
		localVarQueryParams.Add("versionId", parameterToString(*r.versionId, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.taskId != nil {
		localVarQueryParams.Add("taskId", parameterToString(*r.taskId, ""))
	}
	if r.projectId != nil {
		localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.categoryId != nil {
		localVarQueryParams.Add("categoryId", parameterToString(*r.categoryId, ""))
	}
	if r.skipInternalFiles != nil {
		localVarQueryParams.Add("skipInternalFiles", parameterToString(*r.skipInternalFiles, ""))
	}
	if r.skipExternalFiles != nil {
		localVarQueryParams.Add("skipExternalFiles", parameterToString(*r.skipExternalFiles, ""))
	}
	if r.showDeleted != nil {
		localVarQueryParams.Add("showDeleted", parameterToString(*r.showDeleted, ""))
	}
	if r.searchAllFields != nil {
		localVarQueryParams.Add("searchAllFields", parameterToString(*r.searchAllFields, ""))
	}
	if r.matchAllTags != nil {
		localVarQueryParams.Add("matchAllTags", parameterToString(*r.matchAllTags, ""))
	}
	if r.lockedOnly != nil {
		localVarQueryParams.Add("lockedOnly", parameterToString(*r.lockedOnly, ""))
	}
	if r.getVersions != nil {
		localVarQueryParams.Add("getVersions", parameterToString(*r.getVersions, ""))
	}
	if r.getVersionReactions != nil {
		localVarQueryParams.Add("getVersionReactions", parameterToString(*r.getVersionReactions, ""))
	}
	if r.getRelatedItems != nil {
		localVarQueryParams.Add("getRelatedItems", parameterToString(*r.getRelatedItems, ""))
	}
	if r.getReactions != nil {
		localVarQueryParams.Add("getReactions", parameterToString(*r.getReactions, ""))
	}
	if r.getLikes != nil {
		localVarQueryParams.Add("getLikes", parameterToString(*r.getLikes, ""))
	}
	if r.getComments != nil {
		localVarQueryParams.Add("getComments", parameterToString(*r.getComments, ""))
	}
	if r.fromDocumentEditor != nil {
		localVarQueryParams.Add("fromDocumentEditor", parameterToString(*r.fromDocumentEditor, ""))
	}
	if r.versionIds != nil {
		localVarQueryParams.Add("versionIds", parameterToString(*r.versionIds, "csv"))
	}
	if r.userIds != nil {
		localVarQueryParams.Add("userIds", parameterToString(*r.userIds, "csv"))
	}
	if r.tagIds != nil {
		localVarQueryParams.Add("tagIds", parameterToString(*r.tagIds, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsTasks != nil {
		localVarQueryParams.Add("fields[tasks]", parameterToString(*r.fieldsTasks, "csv"))
	}
	if r.fieldsTags != nil {
		localVarQueryParams.Add("fields[tags]", parameterToString(*r.fieldsTags, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsMessages != nil {
		localVarQueryParams.Add("fields[messages]", parameterToString(*r.fieldsMessages, "csv"))
	}
	if r.fieldsFileCategories != nil {
		localVarQueryParams.Add("fields[fileCategories]", parameterToString(*r.fieldsFileCategories, "csv"))
	}
	if r.fieldsComments != nil {
		localVarQueryParams.Add("fields[comments]", parameterToString(*r.fieldsComments, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3FilesUsageJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
	projectId *int32
	include *[]string
	fieldsProjects *[]string
}

func (r ApiGETProjectsApiV3FilesUsageJsonRequest) ProjectId(projectId int32) ApiGETProjectsApiV3FilesUsageJsonRequest {
	r.projectId = &projectId
	return r
}
func (r ApiGETProjectsApiV3FilesUsageJsonRequest) Include(include []string) ApiGETProjectsApiV3FilesUsageJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3FilesUsageJsonRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3FilesUsageJsonRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}

func (r ApiGETProjectsApiV3FilesUsageJsonRequest) Execute() (FileUsageResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3FilesUsageJsonExecute(r)
}

/*
 * GETProjectsApiV3FilesUsageJson Retrieve file usage on account
 * Retrieves all file space used on account.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsApiV3FilesUsageJsonRequest
 */
func (a *FilesApiService) GETProjectsApiV3FilesUsageJson(ctx _context.Context) ApiGETProjectsApiV3FilesUsageJsonRequest {
	return ApiGETProjectsApiV3FilesUsageJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return FileUsageResponse
 */
func (a *FilesApiService) GETProjectsApiV3FilesUsageJsonExecute(r ApiGETProjectsApiV3FilesUsageJsonRequest) (FileUsageResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileUsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.GETProjectsApiV3FilesUsageJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/files/usage.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.projectId != nil {
		localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3FilesfileIdJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
	fileId int32
	uploadedStartDate *string
	uploadedEndDate *string
	updatedAfterDate *time.Time
	updatedAfter *time.Time
	status *string
	searchTerm *string
	projectType *string
	orderMode *string
	orderBy *string
	versionId *int32
	version *int32
	taskId *int32
	projectId *int32
	pageSize *int32
	page *int32
	id *int32
	categoryId *int32
	skipInternalFiles *bool
	skipExternalFiles *bool
	showDeleted *bool
	searchAllFields *bool
	matchAllTags *bool
	lockedOnly *bool
	getVersions *bool
	getVersionReactions *bool
	getRelatedItems *bool
	getReactions *bool
	getLikes *bool
	getComments *bool
	fromDocumentEditor *bool
	versionIds *[]int32
	userIds *[]int32
	tagIds *[]int32
	include *[]string
	fieldsUsers *[]string
	fieldsTasks *[]string
	fieldsTags *[]string
	fieldsProjects *[]string
	fieldsMessages *[]string
	fieldsFileCategories *[]string
	fieldsComments *[]string
}

func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) UploadedStartDate(uploadedStartDate string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.uploadedStartDate = &uploadedStartDate
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) UploadedEndDate(uploadedEndDate string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.uploadedEndDate = &uploadedEndDate
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) UpdatedAfterDate(updatedAfterDate time.Time) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.updatedAfterDate = &updatedAfterDate
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) UpdatedAfter(updatedAfter time.Time) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.updatedAfter = &updatedAfter
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) Status(status string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.status = &status
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) SearchTerm(searchTerm string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.searchTerm = &searchTerm
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) ProjectType(projectType string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) OrderMode(orderMode string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.orderMode = &orderMode
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) OrderBy(orderBy string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.orderBy = &orderBy
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) VersionId(versionId int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.versionId = &versionId
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) Version(version int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.version = &version
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) TaskId(taskId int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.taskId = &taskId
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) ProjectId(projectId int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.projectId = &projectId
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) PageSize(pageSize int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) Page(page int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) Id(id int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.id = &id
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) CategoryId(categoryId int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.categoryId = &categoryId
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) SkipInternalFiles(skipInternalFiles bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.skipInternalFiles = &skipInternalFiles
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) SkipExternalFiles(skipExternalFiles bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.skipExternalFiles = &skipExternalFiles
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) ShowDeleted(showDeleted bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.showDeleted = &showDeleted
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) SearchAllFields(searchAllFields bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.searchAllFields = &searchAllFields
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) MatchAllTags(matchAllTags bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.matchAllTags = &matchAllTags
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) LockedOnly(lockedOnly bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.lockedOnly = &lockedOnly
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) GetVersions(getVersions bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.getVersions = &getVersions
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) GetVersionReactions(getVersionReactions bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.getVersionReactions = &getVersionReactions
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) GetRelatedItems(getRelatedItems bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.getRelatedItems = &getRelatedItems
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) GetReactions(getReactions bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.getReactions = &getReactions
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) GetLikes(getLikes bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.getLikes = &getLikes
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) GetComments(getComments bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.getComments = &getComments
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) FromDocumentEditor(fromDocumentEditor bool) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.fromDocumentEditor = &fromDocumentEditor
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) VersionIds(versionIds []int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.versionIds = &versionIds
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) UserIds(userIds []int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.userIds = &userIds
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) TagIds(tagIds []int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.tagIds = &tagIds
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) Include(include []string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) FieldsTasks(fieldsTasks []string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.fieldsTasks = &fieldsTasks
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) FieldsTags(fieldsTags []string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.fieldsTags = &fieldsTags
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) FieldsMessages(fieldsMessages []string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.fieldsMessages = &fieldsMessages
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) FieldsFileCategories(fieldsFileCategories []string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.fieldsFileCategories = &fieldsFileCategories
	return r
}
func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) FieldsComments(fieldsComments []string) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	r.fieldsComments = &fieldsComments
	return r
}

func (r ApiGETProjectsApiV3FilesfileIdJsonRequest) Execute() (FileResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3FilesfileIdJsonExecute(r)
}

/*
 * GETProjectsApiV3FilesfileIdJson Get a specific file.
 * Get a single file by project file id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param fileId
 * @return ApiGETProjectsApiV3FilesfileIdJsonRequest
 */
func (a *FilesApiService) GETProjectsApiV3FilesfileIdJson(ctx _context.Context, fileId int32) ApiGETProjectsApiV3FilesfileIdJsonRequest {
	return ApiGETProjectsApiV3FilesfileIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

/*
 * Execute executes the request
 * @return FileResponse
 */
func (a *FilesApiService) GETProjectsApiV3FilesfileIdJsonExecute(r ApiGETProjectsApiV3FilesfileIdJsonRequest) (FileResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.GETProjectsApiV3FilesfileIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/files/{fileId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", _neturl.PathEscape(parameterToString(r.fileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.uploadedStartDate != nil {
		localVarQueryParams.Add("uploadedStartDate", parameterToString(*r.uploadedStartDate, ""))
	}
	if r.uploadedEndDate != nil {
		localVarQueryParams.Add("uploadedEndDate", parameterToString(*r.uploadedEndDate, ""))
	}
	if r.updatedAfterDate != nil {
		localVarQueryParams.Add("updatedAfterDate", parameterToString(*r.updatedAfterDate, ""))
	}
	if r.updatedAfter != nil {
		localVarQueryParams.Add("updatedAfter", parameterToString(*r.updatedAfter, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.searchTerm != nil {
		localVarQueryParams.Add("searchTerm", parameterToString(*r.searchTerm, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.orderMode != nil {
		localVarQueryParams.Add("orderMode", parameterToString(*r.orderMode, ""))
	}
	if r.orderBy != nil {
		localVarQueryParams.Add("orderBy", parameterToString(*r.orderBy, ""))
	}
	if r.versionId != nil {
		localVarQueryParams.Add("versionId", parameterToString(*r.versionId, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.taskId != nil {
		localVarQueryParams.Add("taskId", parameterToString(*r.taskId, ""))
	}
	if r.projectId != nil {
		localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.categoryId != nil {
		localVarQueryParams.Add("categoryId", parameterToString(*r.categoryId, ""))
	}
	if r.skipInternalFiles != nil {
		localVarQueryParams.Add("skipInternalFiles", parameterToString(*r.skipInternalFiles, ""))
	}
	if r.skipExternalFiles != nil {
		localVarQueryParams.Add("skipExternalFiles", parameterToString(*r.skipExternalFiles, ""))
	}
	if r.showDeleted != nil {
		localVarQueryParams.Add("showDeleted", parameterToString(*r.showDeleted, ""))
	}
	if r.searchAllFields != nil {
		localVarQueryParams.Add("searchAllFields", parameterToString(*r.searchAllFields, ""))
	}
	if r.matchAllTags != nil {
		localVarQueryParams.Add("matchAllTags", parameterToString(*r.matchAllTags, ""))
	}
	if r.lockedOnly != nil {
		localVarQueryParams.Add("lockedOnly", parameterToString(*r.lockedOnly, ""))
	}
	if r.getVersions != nil {
		localVarQueryParams.Add("getVersions", parameterToString(*r.getVersions, ""))
	}
	if r.getVersionReactions != nil {
		localVarQueryParams.Add("getVersionReactions", parameterToString(*r.getVersionReactions, ""))
	}
	if r.getRelatedItems != nil {
		localVarQueryParams.Add("getRelatedItems", parameterToString(*r.getRelatedItems, ""))
	}
	if r.getReactions != nil {
		localVarQueryParams.Add("getReactions", parameterToString(*r.getReactions, ""))
	}
	if r.getLikes != nil {
		localVarQueryParams.Add("getLikes", parameterToString(*r.getLikes, ""))
	}
	if r.getComments != nil {
		localVarQueryParams.Add("getComments", parameterToString(*r.getComments, ""))
	}
	if r.fromDocumentEditor != nil {
		localVarQueryParams.Add("fromDocumentEditor", parameterToString(*r.fromDocumentEditor, ""))
	}
	if r.versionIds != nil {
		localVarQueryParams.Add("versionIds", parameterToString(*r.versionIds, "csv"))
	}
	if r.userIds != nil {
		localVarQueryParams.Add("userIds", parameterToString(*r.userIds, "csv"))
	}
	if r.tagIds != nil {
		localVarQueryParams.Add("tagIds", parameterToString(*r.tagIds, "csv"))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsTasks != nil {
		localVarQueryParams.Add("fields[tasks]", parameterToString(*r.fieldsTasks, "csv"))
	}
	if r.fieldsTags != nil {
		localVarQueryParams.Add("fields[tags]", parameterToString(*r.fieldsTags, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsMessages != nil {
		localVarQueryParams.Add("fields[messages]", parameterToString(*r.fieldsMessages, "csv"))
	}
	if r.fieldsFileCategories != nil {
		localVarQueryParams.Add("fields[fileCategories]", parameterToString(*r.fieldsFileCategories, "csv"))
	}
	if r.fieldsComments != nil {
		localVarQueryParams.Add("fields[comments]", parameterToString(*r.fieldsComments, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3FileversionidJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
	id2 int32
	id *int32
	getReactions *bool
	include *[]string
	fieldsUsers *[]string
	fieldsProjects *[]string
	fieldsFiles *[]string
}

func (r ApiGETProjectsApiV3FileversionidJsonRequest) Id(id int32) ApiGETProjectsApiV3FileversionidJsonRequest {
	r.id = &id
	return r
}
func (r ApiGETProjectsApiV3FileversionidJsonRequest) GetReactions(getReactions bool) ApiGETProjectsApiV3FileversionidJsonRequest {
	r.getReactions = &getReactions
	return r
}
func (r ApiGETProjectsApiV3FileversionidJsonRequest) Include(include []string) ApiGETProjectsApiV3FileversionidJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3FileversionidJsonRequest) FieldsUsers(fieldsUsers []string) ApiGETProjectsApiV3FileversionidJsonRequest {
	r.fieldsUsers = &fieldsUsers
	return r
}
func (r ApiGETProjectsApiV3FileversionidJsonRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3FileversionidJsonRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}
func (r ApiGETProjectsApiV3FileversionidJsonRequest) FieldsFiles(fieldsFiles []string) ApiGETProjectsApiV3FileversionidJsonRequest {
	r.fieldsFiles = &fieldsFiles
	return r
}

func (r ApiGETProjectsApiV3FileversionidJsonRequest) Execute() (FileversionResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3FileversionidJsonExecute(r)
}

/*
 * GETProjectsApiV3FileversionidJson Get a specific fileversion.
 * Retrieve a fileversion by id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id2
 * @return ApiGETProjectsApiV3FileversionidJsonRequest
 */
func (a *FilesApiService) GETProjectsApiV3FileversionidJson(ctx _context.Context, id2 int32) ApiGETProjectsApiV3FileversionidJsonRequest {
	return ApiGETProjectsApiV3FileversionidJsonRequest{
		ApiService: a,
		ctx: ctx,
		id2: id2,
	}
}

/*
 * Execute executes the request
 * @return FileversionResponse
 */
func (a *FilesApiService) GETProjectsApiV3FileversionidJsonExecute(r ApiGETProjectsApiV3FileversionidJsonRequest) (FileversionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileversionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.GETProjectsApiV3FileversionidJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/fileversion/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id2, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.getReactions != nil {
		localVarQueryParams.Add("getReactions", parameterToString(*r.getReactions, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsUsers != nil {
		localVarQueryParams.Add("fields[users]", parameterToString(*r.fieldsUsers, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	if r.fieldsFiles != nil {
		localVarQueryParams.Add("fields[files]", parameterToString(*r.fieldsFiles, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
	projectId2 int32
	projectId *int32
	include *[]string
	fieldsProjects *[]string
}

func (r ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest) ProjectId(projectId int32) ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest {
	r.projectId = &projectId
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest) Include(include []string) ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest) FieldsProjects(fieldsProjects []string) ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest {
	r.fieldsProjects = &fieldsProjects
	return r
}

func (r ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest) Execute() (FileUsageResponse, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsApiV3ProjectsprojectIdFilesUsageJsonExecute(r)
}

/*
 * GETProjectsApiV3ProjectsprojectIdFilesUsageJson Retrieve file usage on a project
 * Retrieves all file space used on account for a specific project.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId2
 * @return ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest
 */
func (a *FilesApiService) GETProjectsApiV3ProjectsprojectIdFilesUsageJson(ctx _context.Context, projectId2 int32) ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest {
	return ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest{
		ApiService: a,
		ctx: ctx,
		projectId2: projectId2,
	}
}

/*
 * Execute executes the request
 * @return FileUsageResponse
 */
func (a *FilesApiService) GETProjectsApiV3ProjectsprojectIdFilesUsageJsonExecute(r ApiGETProjectsApiV3ProjectsprojectIdFilesUsageJsonRequest) (FileUsageResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileUsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.GETProjectsApiV3ProjectsprojectIdFilesUsageJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/projects/{projectId}/files/usage.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId2, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.projectId != nil {
		localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, "csv"))
	}
	if r.fieldsProjects != nil {
		localVarQueryParams.Add("fields[projects]", parameterToString(*r.fieldsProjects, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPATCHProjectsApiV3FilesfileIdJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
	fileId int32
	fileRequest *FileRequest
}

func (r ApiPATCHProjectsApiV3FilesfileIdJsonRequest) FileRequest(fileRequest FileRequest) ApiPATCHProjectsApiV3FilesfileIdJsonRequest {
	r.fileRequest = &fileRequest
	return r
}

func (r ApiPATCHProjectsApiV3FilesfileIdJsonRequest) Execute() (FileResponse, *_nethttp.Response, error) {
	return r.ApiService.PATCHProjectsApiV3FilesfileIdJsonExecute(r)
}

/*
 * PATCHProjectsApiV3FilesfileIdJson Update an existing file
 * Updates an existing file.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param fileId
 * @return ApiPATCHProjectsApiV3FilesfileIdJsonRequest
 */
func (a *FilesApiService) PATCHProjectsApiV3FilesfileIdJson(ctx _context.Context, fileId int32) ApiPATCHProjectsApiV3FilesfileIdJsonRequest {
	return ApiPATCHProjectsApiV3FilesfileIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

/*
 * Execute executes the request
 * @return FileResponse
 */
func (a *FilesApiService) PATCHProjectsApiV3FilesfileIdJsonExecute(r ApiPATCHProjectsApiV3FilesfileIdJsonRequest) (FileResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.PATCHProjectsApiV3FilesfileIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/files/{fileId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", _neturl.PathEscape(parameterToString(r.fileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fileRequest == nil {
		return localVarReturnValue, nil, reportError("fileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTProjectsApiV3FilesArchiveJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
	fileArchiveRequest *FileArchiveRequest
}

func (r ApiPOSTProjectsApiV3FilesArchiveJsonRequest) FileArchiveRequest(fileArchiveRequest FileArchiveRequest) ApiPOSTProjectsApiV3FilesArchiveJsonRequest {
	r.fileArchiveRequest = &fileArchiveRequest
	return r
}

func (r ApiPOSTProjectsApiV3FilesArchiveJsonRequest) Execute() (FileArchiveResponse, *_nethttp.Response, error) {
	return r.ApiService.POSTProjectsApiV3FilesArchiveJsonExecute(r)
}

/*
 * POSTProjectsApiV3FilesArchiveJson Returns an URL for multiple files
 * Returns an URL to download multiple files at once.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPOSTProjectsApiV3FilesArchiveJsonRequest
 */
func (a *FilesApiService) POSTProjectsApiV3FilesArchiveJson(ctx _context.Context) ApiPOSTProjectsApiV3FilesArchiveJsonRequest {
	return ApiPOSTProjectsApiV3FilesArchiveJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return FileArchiveResponse
 */
func (a *FilesApiService) POSTProjectsApiV3FilesArchiveJsonExecute(r ApiPOSTProjectsApiV3FilesArchiveJsonRequest) (FileArchiveResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileArchiveResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.POSTProjectsApiV3FilesArchiveJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/files/archive.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fileArchiveRequest == nil {
		return localVarReturnValue, nil, reportError("fileArchiveRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileArchiveRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTProjectsApiV3FilesprojectFileIdJsonRequest struct {
	ctx _context.Context
	ApiService *FilesApiService
	projectFileId int32
	fileversionRequest *FileversionRequest
}

func (r ApiPOSTProjectsApiV3FilesprojectFileIdJsonRequest) FileversionRequest(fileversionRequest FileversionRequest) ApiPOSTProjectsApiV3FilesprojectFileIdJsonRequest {
	r.fileversionRequest = &fileversionRequest
	return r
}

func (r ApiPOSTProjectsApiV3FilesprojectFileIdJsonRequest) Execute() (FileversionResponse, *_nethttp.Response, error) {
	return r.ApiService.POSTProjectsApiV3FilesprojectFileIdJsonExecute(r)
}

/*
 * POSTProjectsApiV3FilesprojectFileIdJson Create a new fileversion for the project file id.
 * Creates a new fileversion for the project file id specified.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectFileId
 * @return ApiPOSTProjectsApiV3FilesprojectFileIdJsonRequest
 */
func (a *FilesApiService) POSTProjectsApiV3FilesprojectFileIdJson(ctx _context.Context, projectFileId int32) ApiPOSTProjectsApiV3FilesprojectFileIdJsonRequest {
	return ApiPOSTProjectsApiV3FilesprojectFileIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		projectFileId: projectFileId,
	}
}

/*
 * Execute executes the request
 * @return FileversionResponse
 */
func (a *FilesApiService) POSTProjectsApiV3FilesprojectFileIdJsonExecute(r ApiPOSTProjectsApiV3FilesprojectFileIdJsonRequest) (FileversionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileversionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesApiService.POSTProjectsApiV3FilesprojectFileIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v3/files/{projectFileId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projectFileId"+"}", _neturl.PathEscape(parameterToString(r.projectFileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fileversionRequest == nil {
		return localVarReturnValue, nil, reportError("fileversionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileversionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ViewErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
