/*
 * Teamwork Projects API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pmv1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// TimeTrackingApiService TimeTrackingApi service
type TimeTrackingApiService service

type ApiDELETETimeEntriesIdJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
}


func (r ApiDELETETimeEntriesIdJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.DELETETimeEntriesIdJsonExecute(r)
}

/*
 * DELETETimeEntriesIdJson Delete a Time-Entry
 * Deletes the referenced Time-Entry.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiDELETETimeEntriesIdJsonRequest
 */
func (a *TimeTrackingApiService) DELETETimeEntriesIdJson(ctx _context.Context, id string) ApiDELETETimeEntriesIdJsonRequest {
	return ApiDELETETimeEntriesIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *TimeTrackingApiService) DELETETimeEntriesIdJsonExecute(r ApiDELETETimeEntriesIdJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.DELETETimeEntriesIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/time_entries/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETMeTimersJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	projectId *string
	taskId *string
	runningTimersOnly *bool
}

func (r ApiGETMeTimersJsonRequest) ProjectId(projectId string) ApiGETMeTimersJsonRequest {
	r.projectId = &projectId
	return r
}
func (r ApiGETMeTimersJsonRequest) TaskId(taskId string) ApiGETMeTimersJsonRequest {
	r.taskId = &taskId
	return r
}
func (r ApiGETMeTimersJsonRequest) RunningTimersOnly(runningTimersOnly bool) ApiGETMeTimersJsonRequest {
	r.runningTimersOnly = &runningTimersOnly
	return r
}

func (r ApiGETMeTimersJsonRequest) Execute() (InlineResponse20030, *_nethttp.Response, error) {
	return r.ApiService.GETMeTimersJsonExecute(r)
}

/*
 * GETMeTimersJson Get all your Running Timers
 * Will get all your running timers or the person you are logged in as.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETMeTimersJsonRequest
 */
func (a *TimeTrackingApiService) GETMeTimersJson(ctx _context.Context) ApiGETMeTimersJsonRequest {
	return ApiGETMeTimersJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20030
 */
func (a *TimeTrackingApiService) GETMeTimersJsonExecute(r ApiGETMeTimersJsonRequest) (InlineResponse20030, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20030
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETMeTimersJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/timers.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.projectId != nil {
		localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.taskId != nil {
		localVarQueryParams.Add("taskId", parameterToString(*r.taskId, ""))
	}
	if r.runningTimersOnly != nil {
		localVarQueryParams.Add("runningTimersOnly", parameterToString(*r.runningTimersOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETPeopleIdLoggedtimeJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
	m *string
	y *string
	page *string
	pageSize *string
}

func (r ApiGETPeopleIdLoggedtimeJsonRequest) M(m string) ApiGETPeopleIdLoggedtimeJsonRequest {
	r.m = &m
	return r
}
func (r ApiGETPeopleIdLoggedtimeJsonRequest) Y(y string) ApiGETPeopleIdLoggedtimeJsonRequest {
	r.y = &y
	return r
}
func (r ApiGETPeopleIdLoggedtimeJsonRequest) Page(page string) ApiGETPeopleIdLoggedtimeJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETPeopleIdLoggedtimeJsonRequest) PageSize(pageSize string) ApiGETPeopleIdLoggedtimeJsonRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGETPeopleIdLoggedtimeJsonRequest) Execute() (InlineResponse20040, *_nethttp.Response, error) {
	return r.ApiService.GETPeopleIdLoggedtimeJsonExecute(r)
}

/*
 * GETPeopleIdLoggedtimeJson Get Logged Time by Person
 * Total billable and non billable time per user. 

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETPeopleIdLoggedtimeJsonRequest
 */
func (a *TimeTrackingApiService) GETPeopleIdLoggedtimeJson(ctx _context.Context, id string) ApiGETPeopleIdLoggedtimeJsonRequest {
	return ApiGETPeopleIdLoggedtimeJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20040
 */
func (a *TimeTrackingApiService) GETPeopleIdLoggedtimeJsonExecute(r ApiGETPeopleIdLoggedtimeJsonRequest) (InlineResponse20040, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20040
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETPeopleIdLoggedtimeJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/people/{id}/loggedtime.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.m != nil {
		localVarQueryParams.Add("m", parameterToString(*r.m, ""))
	}
	if r.y != nil {
		localVarQueryParams.Add("y", parameterToString(*r.y, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETPeopleIdTimersJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
	projectId *string
	taskId *string
	runningTimersOnly *bool
}

func (r ApiGETPeopleIdTimersJsonRequest) ProjectId(projectId string) ApiGETPeopleIdTimersJsonRequest {
	r.projectId = &projectId
	return r
}
func (r ApiGETPeopleIdTimersJsonRequest) TaskId(taskId string) ApiGETPeopleIdTimersJsonRequest {
	r.taskId = &taskId
	return r
}
func (r ApiGETPeopleIdTimersJsonRequest) RunningTimersOnly(runningTimersOnly bool) ApiGETPeopleIdTimersJsonRequest {
	r.runningTimersOnly = &runningTimersOnly
	return r
}

func (r ApiGETPeopleIdTimersJsonRequest) Execute() (InlineResponse20030, *_nethttp.Response, error) {
	return r.ApiService.GETPeopleIdTimersJsonExecute(r)
}

/*
 * GETPeopleIdTimersJson Get all Running Timers for a specific Person
 * Pass in the people id to get timers for one specific user.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETPeopleIdTimersJsonRequest
 */
func (a *TimeTrackingApiService) GETPeopleIdTimersJson(ctx _context.Context, id string) ApiGETPeopleIdTimersJsonRequest {
	return ApiGETPeopleIdTimersJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20030
 */
func (a *TimeTrackingApiService) GETPeopleIdTimersJsonExecute(r ApiGETPeopleIdTimersJsonRequest) (InlineResponse20030, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20030
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETPeopleIdTimersJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/people/{id}/timers.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.projectId != nil {
		localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.taskId != nil {
		localVarQueryParams.Add("taskId", parameterToString(*r.taskId, ""))
	}
	if r.runningTimersOnly != nil {
		localVarQueryParams.Add("runningTimersOnly", parameterToString(*r.runningTimersOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsEstimatedtimeTotalJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
}


func (r ApiGETProjectsEstimatedtimeTotalJsonRequest) Execute() (InlineResponse20057, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsEstimatedtimeTotalJsonExecute(r)
}

/*
 * GETProjectsEstimatedtimeTotalJson Estimated Time Totals on Projects
 * Returns estimated time totals across all projects.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsEstimatedtimeTotalJsonRequest
 */
func (a *TimeTrackingApiService) GETProjectsEstimatedtimeTotalJson(ctx _context.Context) ApiGETProjectsEstimatedtimeTotalJsonRequest {
	return ApiGETProjectsEstimatedtimeTotalJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20057
 */
func (a *TimeTrackingApiService) GETProjectsEstimatedtimeTotalJsonExecute(r ApiGETProjectsEstimatedtimeTotalJsonRequest) (InlineResponse20057, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20057
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETProjectsEstimatedtimeTotalJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/estimatedtime/total.json."

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsIdTimeEntriesJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
	page *int32
	fromdate *string
	fromtime *string
	todate *string
	totime *string
	sortby *string
	sortorder *string
	userId *int32
	billableType *string
	invoicedType *string
	projectType *string
	showDeleted *string
	tagIds *string
	updatedAfterDate *string
	pageSize *string
	taskTagIds *string
}

func (r ApiGETProjectsIdTimeEntriesJsonRequest) Page(page int32) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) Fromdate(fromdate string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.fromdate = &fromdate
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) Fromtime(fromtime string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.fromtime = &fromtime
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) Todate(todate string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.todate = &todate
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) Totime(totime string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.totime = &totime
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) Sortby(sortby string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.sortby = &sortby
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) Sortorder(sortorder string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.sortorder = &sortorder
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) UserId(userId int32) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.userId = &userId
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) BillableType(billableType string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.billableType = &billableType
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) InvoicedType(invoicedType string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.invoicedType = &invoicedType
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) ProjectType(projectType string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) ShowDeleted(showDeleted string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.showDeleted = &showDeleted
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) TagIds(tagIds string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.tagIds = &tagIds
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) UpdatedAfterDate(updatedAfterDate string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.updatedAfterDate = &updatedAfterDate
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) PageSize(pageSize string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsIdTimeEntriesJsonRequest) TaskTagIds(taskTagIds string) ApiGETProjectsIdTimeEntriesJsonRequest {
	r.taskTagIds = &taskTagIds
	return r
}

func (r ApiGETProjectsIdTimeEntriesJsonRequest) Execute() (InlineResponse20079, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsIdTimeEntriesJsonExecute(r)
}

/*
 * GETProjectsIdTimeEntriesJson Retrieve all Time Entries for a Project
 * In ascending order by date, this retrieves time entries for all projects.
A page contains 100 entries, but you can increase the page size to a maxium of 500 entries by using 'pageSize' parameter. To select a different page of data, set the 'page' query parameter to a value greater than zero.
The total number of time entries in the project is in the X-Records HTTP header. X-Pages will be set to the total number of pages, and X-Page will be set to the current page.

<h4>Additional Notes:</h4>
The date field returned in the response is in UTC date/time
The toDate, toTime, fromDate and fromTime are specified in your timezone.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETProjectsIdTimeEntriesJsonRequest
 */
func (a *TimeTrackingApiService) GETProjectsIdTimeEntriesJson(ctx _context.Context, id string) ApiGETProjectsIdTimeEntriesJsonRequest {
	return ApiGETProjectsIdTimeEntriesJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20079
 */
func (a *TimeTrackingApiService) GETProjectsIdTimeEntriesJsonExecute(r ApiGETProjectsIdTimeEntriesJsonRequest) (InlineResponse20079, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20079
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETProjectsIdTimeEntriesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}/time_entries.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.fromdate != nil {
		localVarQueryParams.Add("fromdate", parameterToString(*r.fromdate, ""))
	}
	if r.fromtime != nil {
		localVarQueryParams.Add("fromtime", parameterToString(*r.fromtime, ""))
	}
	if r.todate != nil {
		localVarQueryParams.Add("todate", parameterToString(*r.todate, ""))
	}
	if r.totime != nil {
		localVarQueryParams.Add("totime", parameterToString(*r.totime, ""))
	}
	if r.sortby != nil {
		localVarQueryParams.Add("sortby", parameterToString(*r.sortby, ""))
	}
	if r.sortorder != nil {
		localVarQueryParams.Add("sortorder", parameterToString(*r.sortorder, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.billableType != nil {
		localVarQueryParams.Add("billableType", parameterToString(*r.billableType, ""))
	}
	if r.invoicedType != nil {
		localVarQueryParams.Add("invoicedType", parameterToString(*r.invoicedType, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.showDeleted != nil {
		localVarQueryParams.Add("showDeleted", parameterToString(*r.showDeleted, ""))
	}
	if r.tagIds != nil {
		localVarQueryParams.Add("tagIds", parameterToString(*r.tagIds, ""))
	}
	if r.updatedAfterDate != nil {
		localVarQueryParams.Add("updatedAfterDate", parameterToString(*r.updatedAfterDate, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.taskTagIds != nil {
		localVarQueryParams.Add("taskTagIds", parameterToString(*r.taskTagIds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsIdTimeTotalJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
	fromDate *string
	fromTime *string
	toDate *string
	toTime *string
	userId *int32
	projectType *string
	page *int32
	pageSize *int32
}

func (r ApiGETProjectsIdTimeTotalJsonRequest) FromDate(fromDate string) ApiGETProjectsIdTimeTotalJsonRequest {
	r.fromDate = &fromDate
	return r
}
func (r ApiGETProjectsIdTimeTotalJsonRequest) FromTime(fromTime string) ApiGETProjectsIdTimeTotalJsonRequest {
	r.fromTime = &fromTime
	return r
}
func (r ApiGETProjectsIdTimeTotalJsonRequest) ToDate(toDate string) ApiGETProjectsIdTimeTotalJsonRequest {
	r.toDate = &toDate
	return r
}
func (r ApiGETProjectsIdTimeTotalJsonRequest) ToTime(toTime string) ApiGETProjectsIdTimeTotalJsonRequest {
	r.toTime = &toTime
	return r
}
func (r ApiGETProjectsIdTimeTotalJsonRequest) UserId(userId int32) ApiGETProjectsIdTimeTotalJsonRequest {
	r.userId = &userId
	return r
}
func (r ApiGETProjectsIdTimeTotalJsonRequest) ProjectType(projectType string) ApiGETProjectsIdTimeTotalJsonRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETProjectsIdTimeTotalJsonRequest) Page(page int32) ApiGETProjectsIdTimeTotalJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsIdTimeTotalJsonRequest) PageSize(pageSize int32) ApiGETProjectsIdTimeTotalJsonRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGETProjectsIdTimeTotalJsonRequest) Execute() (InlineResponse20078, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsIdTimeTotalJsonExecute(r)
}

/*
 * GETProjectsIdTimeTotalJson Time Totals on a Project
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETProjectsIdTimeTotalJsonRequest
 */
func (a *TimeTrackingApiService) GETProjectsIdTimeTotalJson(ctx _context.Context, id string) ApiGETProjectsIdTimeTotalJsonRequest {
	return ApiGETProjectsIdTimeTotalJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20078
 */
func (a *TimeTrackingApiService) GETProjectsIdTimeTotalJsonExecute(r ApiGETProjectsIdTimeTotalJsonRequest) (InlineResponse20078, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20078
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETProjectsIdTimeTotalJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}/time/total.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fromDate != nil {
		localVarQueryParams.Add("fromDate", parameterToString(*r.fromDate, ""))
	}
	if r.fromTime != nil {
		localVarQueryParams.Add("fromTime", parameterToString(*r.fromTime, ""))
	}
	if r.toDate != nil {
		localVarQueryParams.Add("toDate", parameterToString(*r.toDate, ""))
	}
	if r.toTime != nil {
		localVarQueryParams.Add("toTime", parameterToString(*r.toTime, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsTimeTotalJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
}


func (r ApiGETProjectsTimeTotalJsonRequest) Execute() (InlineResponse20058, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsTimeTotalJsonExecute(r)
}

/*
 * GETProjectsTimeTotalJson Time Totals across Projects
 * Returns time totals grouped by project.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETProjectsTimeTotalJsonRequest
 */
func (a *TimeTrackingApiService) GETProjectsTimeTotalJson(ctx _context.Context) ApiGETProjectsTimeTotalJsonRequest {
	return ApiGETProjectsTimeTotalJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20058
 */
func (a *TimeTrackingApiService) GETProjectsTimeTotalJsonExecute(r ApiGETProjectsTimeTotalJsonRequest) (InlineResponse20058, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20058
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETProjectsTimeTotalJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/time/total.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasklistsIdTimeTotalJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
	fromDate *string
	fromTime *string
	toDate *string
	toTime *string
	userId *int32
	projectType *string
}

func (r ApiGETTasklistsIdTimeTotalJsonRequest) FromDate(fromDate string) ApiGETTasklistsIdTimeTotalJsonRequest {
	r.fromDate = &fromDate
	return r
}
func (r ApiGETTasklistsIdTimeTotalJsonRequest) FromTime(fromTime string) ApiGETTasklistsIdTimeTotalJsonRequest {
	r.fromTime = &fromTime
	return r
}
func (r ApiGETTasklistsIdTimeTotalJsonRequest) ToDate(toDate string) ApiGETTasklistsIdTimeTotalJsonRequest {
	r.toDate = &toDate
	return r
}
func (r ApiGETTasklistsIdTimeTotalJsonRequest) ToTime(toTime string) ApiGETTasklistsIdTimeTotalJsonRequest {
	r.toTime = &toTime
	return r
}
func (r ApiGETTasklistsIdTimeTotalJsonRequest) UserId(userId int32) ApiGETTasklistsIdTimeTotalJsonRequest {
	r.userId = &userId
	return r
}
func (r ApiGETTasklistsIdTimeTotalJsonRequest) ProjectType(projectType string) ApiGETTasklistsIdTimeTotalJsonRequest {
	r.projectType = &projectType
	return r
}

func (r ApiGETTasklistsIdTimeTotalJsonRequest) Execute() (InlineResponse20098, *_nethttp.Response, error) {
	return r.ApiService.GETTasklistsIdTimeTotalJsonExecute(r)
}

/*
 * GETTasklistsIdTimeTotalJson Total Time on a Tasklist
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETTasklistsIdTimeTotalJsonRequest
 */
func (a *TimeTrackingApiService) GETTasklistsIdTimeTotalJson(ctx _context.Context, id string) ApiGETTasklistsIdTimeTotalJsonRequest {
	return ApiGETTasklistsIdTimeTotalJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20098
 */
func (a *TimeTrackingApiService) GETTasklistsIdTimeTotalJsonExecute(r ApiGETTasklistsIdTimeTotalJsonRequest) (InlineResponse20098, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20098
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETTasklistsIdTimeTotalJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasklists/{id}/time/total.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fromDate != nil {
		localVarQueryParams.Add("fromDate", parameterToString(*r.fromDate, ""))
	}
	if r.fromTime != nil {
		localVarQueryParams.Add("fromTime", parameterToString(*r.fromTime, ""))
	}
	if r.toDate != nil {
		localVarQueryParams.Add("toDate", parameterToString(*r.toDate, ""))
	}
	if r.toTime != nil {
		localVarQueryParams.Add("toTime", parameterToString(*r.toTime, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasksIdTimeEntriesJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
}


func (r ApiGETTasksIdTimeEntriesJsonRequest) Execute() (InlineResponse200107, *_nethttp.Response, error) {
	return r.ApiService.GETTasksIdTimeEntriesJsonExecute(r)
}

/*
 * GETTasksIdTimeEntriesJson Retrieve all Task times
 * Retrieves all of the time entries from a submitted todo item.

<h4>Additional Notes:</h4>

- The date field returned in the response is in UTC date/time
- The toDate, toTime, fromDate and fromTime are specified in your timezone.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETTasksIdTimeEntriesJsonRequest
 */
func (a *TimeTrackingApiService) GETTasksIdTimeEntriesJson(ctx _context.Context, id string) ApiGETTasksIdTimeEntriesJsonRequest {
	return ApiGETTasksIdTimeEntriesJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200107
 */
func (a *TimeTrackingApiService) GETTasksIdTimeEntriesJsonExecute(r ApiGETTasksIdTimeEntriesJsonRequest) (InlineResponse200107, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200107
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETTasksIdTimeEntriesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}/time_entries.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasksIdTimeTotalJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
	fromDate *string
	fromTime *string
	toDate *string
	toTime *string
	userId *int32
	projectType *string
}

func (r ApiGETTasksIdTimeTotalJsonRequest) FromDate(fromDate string) ApiGETTasksIdTimeTotalJsonRequest {
	r.fromDate = &fromDate
	return r
}
func (r ApiGETTasksIdTimeTotalJsonRequest) FromTime(fromTime string) ApiGETTasksIdTimeTotalJsonRequest {
	r.fromTime = &fromTime
	return r
}
func (r ApiGETTasksIdTimeTotalJsonRequest) ToDate(toDate string) ApiGETTasksIdTimeTotalJsonRequest {
	r.toDate = &toDate
	return r
}
func (r ApiGETTasksIdTimeTotalJsonRequest) ToTime(toTime string) ApiGETTasksIdTimeTotalJsonRequest {
	r.toTime = &toTime
	return r
}
func (r ApiGETTasksIdTimeTotalJsonRequest) UserId(userId int32) ApiGETTasksIdTimeTotalJsonRequest {
	r.userId = &userId
	return r
}
func (r ApiGETTasksIdTimeTotalJsonRequest) ProjectType(projectType string) ApiGETTasksIdTimeTotalJsonRequest {
	r.projectType = &projectType
	return r
}

func (r ApiGETTasksIdTimeTotalJsonRequest) Execute() (InlineResponse200106, *_nethttp.Response, error) {
	return r.ApiService.GETTasksIdTimeTotalJsonExecute(r)
}

/*
 * GETTasksIdTimeTotalJson Total Time on a Task
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETTasksIdTimeTotalJsonRequest
 */
func (a *TimeTrackingApiService) GETTasksIdTimeTotalJson(ctx _context.Context, id string) ApiGETTasksIdTimeTotalJsonRequest {
	return ApiGETTasksIdTimeTotalJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200106
 */
func (a *TimeTrackingApiService) GETTasksIdTimeTotalJsonExecute(r ApiGETTasksIdTimeTotalJsonRequest) (InlineResponse200106, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200106
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETTasksIdTimeTotalJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}/time/total.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fromDate != nil {
		localVarQueryParams.Add("fromDate", parameterToString(*r.fromDate, ""))
	}
	if r.fromTime != nil {
		localVarQueryParams.Add("fromTime", parameterToString(*r.fromTime, ""))
	}
	if r.toDate != nil {
		localVarQueryParams.Add("toDate", parameterToString(*r.toDate, ""))
	}
	if r.toTime != nil {
		localVarQueryParams.Add("toTime", parameterToString(*r.toTime, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTimeEntriesIdJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
}


func (r ApiGETTimeEntriesIdJsonRequest) Execute() (InlineResponse200112, *_nethttp.Response, error) {
	return r.ApiService.GETTimeEntriesIdJsonExecute(r)
}

/*
 * GETTimeEntriesIdJson Retrieve single Time-Entry
 * Retrieve a Single Time-Entry.

<h4>Additional Notes:</h4>

- The date field returned in the response is in UTC date/time
- The toDate, toTime, fromDate and fromTime are specified in your timezone.
- 
---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETTimeEntriesIdJsonRequest
 */
func (a *TimeTrackingApiService) GETTimeEntriesIdJson(ctx _context.Context, id string) ApiGETTimeEntriesIdJsonRequest {
	return ApiGETTimeEntriesIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200112
 */
func (a *TimeTrackingApiService) GETTimeEntriesIdJsonExecute(r ApiGETTimeEntriesIdJsonRequest) (InlineResponse200112, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200112
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETTimeEntriesIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/time_entries/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTimeEntriesJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	page *int32
	fromdate *string
	fromtime *string
	todate *string
	totime *string
	sortby *string
	sortorder *string
	userId *int32
	billableType *string
	invoicedType *string
	projectType *string
	showDeleted *string
	tagIds *string
	updatedAfterDate *string
	projectId *string
	pageSize *string
	taskTagIds *string
}

func (r ApiGETTimeEntriesJsonRequest) Page(page int32) ApiGETTimeEntriesJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETTimeEntriesJsonRequest) Fromdate(fromdate string) ApiGETTimeEntriesJsonRequest {
	r.fromdate = &fromdate
	return r
}
func (r ApiGETTimeEntriesJsonRequest) Fromtime(fromtime string) ApiGETTimeEntriesJsonRequest {
	r.fromtime = &fromtime
	return r
}
func (r ApiGETTimeEntriesJsonRequest) Todate(todate string) ApiGETTimeEntriesJsonRequest {
	r.todate = &todate
	return r
}
func (r ApiGETTimeEntriesJsonRequest) Totime(totime string) ApiGETTimeEntriesJsonRequest {
	r.totime = &totime
	return r
}
func (r ApiGETTimeEntriesJsonRequest) Sortby(sortby string) ApiGETTimeEntriesJsonRequest {
	r.sortby = &sortby
	return r
}
func (r ApiGETTimeEntriesJsonRequest) Sortorder(sortorder string) ApiGETTimeEntriesJsonRequest {
	r.sortorder = &sortorder
	return r
}
func (r ApiGETTimeEntriesJsonRequest) UserId(userId int32) ApiGETTimeEntriesJsonRequest {
	r.userId = &userId
	return r
}
func (r ApiGETTimeEntriesJsonRequest) BillableType(billableType string) ApiGETTimeEntriesJsonRequest {
	r.billableType = &billableType
	return r
}
func (r ApiGETTimeEntriesJsonRequest) InvoicedType(invoicedType string) ApiGETTimeEntriesJsonRequest {
	r.invoicedType = &invoicedType
	return r
}
func (r ApiGETTimeEntriesJsonRequest) ProjectType(projectType string) ApiGETTimeEntriesJsonRequest {
	r.projectType = &projectType
	return r
}
func (r ApiGETTimeEntriesJsonRequest) ShowDeleted(showDeleted string) ApiGETTimeEntriesJsonRequest {
	r.showDeleted = &showDeleted
	return r
}
func (r ApiGETTimeEntriesJsonRequest) TagIds(tagIds string) ApiGETTimeEntriesJsonRequest {
	r.tagIds = &tagIds
	return r
}
func (r ApiGETTimeEntriesJsonRequest) UpdatedAfterDate(updatedAfterDate string) ApiGETTimeEntriesJsonRequest {
	r.updatedAfterDate = &updatedAfterDate
	return r
}
func (r ApiGETTimeEntriesJsonRequest) ProjectId(projectId string) ApiGETTimeEntriesJsonRequest {
	r.projectId = &projectId
	return r
}
func (r ApiGETTimeEntriesJsonRequest) PageSize(pageSize string) ApiGETTimeEntriesJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETTimeEntriesJsonRequest) TaskTagIds(taskTagIds string) ApiGETTimeEntriesJsonRequest {
	r.taskTagIds = &taskTagIds
	return r
}

func (r ApiGETTimeEntriesJsonRequest) Execute() (InlineResponse200107, *_nethttp.Response, error) {
	return r.ApiService.GETTimeEntriesJsonExecute(r)
}

/*
 * GETTimeEntriesJson Retrieve all Time Entries across all Projects
 * In ascending order by date, this retrieves time entries for all projects.
A page contains 100 entries, but you can increase the page size to a maxium of 500 entries by using 'pageSize' parameter. To select a different page of data, set the 'page' query parameter to a value greater than zero.
The total number of time entries in the project is in the X-Records HTTP header. X-Pages will be set to the total number of pages, and X-Page will be set to the current page.

<h4>Additional Notes:</h4>
The date field returned in the response is in UTC date/time
The toDate, toTime, fromDate and fromTime are specified in your timezone.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETTimeEntriesJsonRequest
 */
func (a *TimeTrackingApiService) GETTimeEntriesJson(ctx _context.Context) ApiGETTimeEntriesJsonRequest {
	return ApiGETTimeEntriesJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200107
 */
func (a *TimeTrackingApiService) GETTimeEntriesJsonExecute(r ApiGETTimeEntriesJsonRequest) (InlineResponse200107, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200107
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETTimeEntriesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/time_entries.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.fromdate != nil {
		localVarQueryParams.Add("fromdate", parameterToString(*r.fromdate, ""))
	}
	if r.fromtime != nil {
		localVarQueryParams.Add("fromtime", parameterToString(*r.fromtime, ""))
	}
	if r.todate != nil {
		localVarQueryParams.Add("todate", parameterToString(*r.todate, ""))
	}
	if r.totime != nil {
		localVarQueryParams.Add("totime", parameterToString(*r.totime, ""))
	}
	if r.sortby != nil {
		localVarQueryParams.Add("sortby", parameterToString(*r.sortby, ""))
	}
	if r.sortorder != nil {
		localVarQueryParams.Add("sortorder", parameterToString(*r.sortorder, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.billableType != nil {
		localVarQueryParams.Add("billableType", parameterToString(*r.billableType, ""))
	}
	if r.invoicedType != nil {
		localVarQueryParams.Add("invoicedType", parameterToString(*r.invoicedType, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	if r.showDeleted != nil {
		localVarQueryParams.Add("showDeleted", parameterToString(*r.showDeleted, ""))
	}
	if r.tagIds != nil {
		localVarQueryParams.Add("tagIds", parameterToString(*r.tagIds, ""))
	}
	if r.updatedAfterDate != nil {
		localVarQueryParams.Add("updatedAfterDate", parameterToString(*r.updatedAfterDate, ""))
	}
	if r.projectId != nil {
		localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.taskTagIds != nil {
		localVarQueryParams.Add("taskTagIds", parameterToString(*r.taskTagIds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTimeTotalJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	fromDate *string
	fromTime *string
	toDate *string
	toTime *string
	userId *int32
	projectType *string
}

func (r ApiGETTimeTotalJsonRequest) FromDate(fromDate string) ApiGETTimeTotalJsonRequest {
	r.fromDate = &fromDate
	return r
}
func (r ApiGETTimeTotalJsonRequest) FromTime(fromTime string) ApiGETTimeTotalJsonRequest {
	r.fromTime = &fromTime
	return r
}
func (r ApiGETTimeTotalJsonRequest) ToDate(toDate string) ApiGETTimeTotalJsonRequest {
	r.toDate = &toDate
	return r
}
func (r ApiGETTimeTotalJsonRequest) ToTime(toTime string) ApiGETTimeTotalJsonRequest {
	r.toTime = &toTime
	return r
}
func (r ApiGETTimeTotalJsonRequest) UserId(userId int32) ApiGETTimeTotalJsonRequest {
	r.userId = &userId
	return r
}
func (r ApiGETTimeTotalJsonRequest) ProjectType(projectType string) ApiGETTimeTotalJsonRequest {
	r.projectType = &projectType
	return r
}

func (r ApiGETTimeTotalJsonRequest) Execute() (InlineResponse200111, *_nethttp.Response, error) {
	return r.ApiService.GETTimeTotalJsonExecute(r)
}

/*
 * GETTimeTotalJson Get Total Time across an Account
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETTimeTotalJsonRequest
 */
func (a *TimeTrackingApiService) GETTimeTotalJson(ctx _context.Context) ApiGETTimeTotalJsonRequest {
	return ApiGETTimeTotalJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200111
 */
func (a *TimeTrackingApiService) GETTimeTotalJsonExecute(r ApiGETTimeTotalJsonRequest) (InlineResponse200111, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200111
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETTimeTotalJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/time/total.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fromDate != nil {
		localVarQueryParams.Add("fromDate", parameterToString(*r.fromDate, ""))
	}
	if r.fromTime != nil {
		localVarQueryParams.Add("fromTime", parameterToString(*r.fromTime, ""))
	}
	if r.toDate != nil {
		localVarQueryParams.Add("toDate", parameterToString(*r.toDate, ""))
	}
	if r.toTime != nil {
		localVarQueryParams.Add("toTime", parameterToString(*r.toTime, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.projectType != nil {
		localVarQueryParams.Add("projectType", parameterToString(*r.projectType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTimersJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	projectId *string
	taskId *string
	runningTimersOnly *bool
}

func (r ApiGETTimersJsonRequest) ProjectId(projectId string) ApiGETTimersJsonRequest {
	r.projectId = &projectId
	return r
}
func (r ApiGETTimersJsonRequest) TaskId(taskId string) ApiGETTimersJsonRequest {
	r.taskId = &taskId
	return r
}
func (r ApiGETTimersJsonRequest) RunningTimersOnly(runningTimersOnly bool) ApiGETTimersJsonRequest {
	r.runningTimersOnly = &runningTimersOnly
	return r
}

func (r ApiGETTimersJsonRequest) Execute() (InlineResponse20030, *_nethttp.Response, error) {
	return r.ApiService.GETTimersJsonExecute(r)
}

/*
 * GETTimersJson Get all Running Timers
 * Brings back all current running timers. Will return a set of existing intervals for each timer. If the timer has never been stopped then this interval will only have a from property set and the you will need to calculate the current duration of the timer.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETTimersJsonRequest
 */
func (a *TimeTrackingApiService) GETTimersJson(ctx _context.Context) ApiGETTimersJsonRequest {
	return ApiGETTimersJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20030
 */
func (a *TimeTrackingApiService) GETTimersJsonExecute(r ApiGETTimersJsonRequest) (InlineResponse20030, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20030
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.GETTimersJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/timers.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.projectId != nil {
		localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	}
	if r.taskId != nil {
		localVarQueryParams.Add("taskId", parameterToString(*r.taskId, ""))
	}
	if r.runningTimersOnly != nil {
		localVarQueryParams.Add("runningTimersOnly", parameterToString(*r.runningTimersOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTProjectsIdTimeEntriesJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
	body *InlineObject75
}

func (r ApiPOSTProjectsIdTimeEntriesJsonRequest) Body(body InlineObject75) ApiPOSTProjectsIdTimeEntriesJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTProjectsIdTimeEntriesJsonRequest) Execute() (InlineResponse2015, *_nethttp.Response, error) {
	return r.ApiService.POSTProjectsIdTimeEntriesJsonExecute(r)
}

/*
 * POSTProjectsIdTimeEntriesJson Create a Time-Entry
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPOSTProjectsIdTimeEntriesJsonRequest
 */
func (a *TimeTrackingApiService) POSTProjectsIdTimeEntriesJson(ctx _context.Context, id string) ApiPOSTProjectsIdTimeEntriesJsonRequest {
	return ApiPOSTProjectsIdTimeEntriesJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2015
 */
func (a *TimeTrackingApiService) POSTProjectsIdTimeEntriesJsonExecute(r ApiPOSTProjectsIdTimeEntriesJsonRequest) (InlineResponse2015, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2015
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.POSTProjectsIdTimeEntriesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}/time_entries.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTTasksIdTimeEntriesJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
	body *InlineObject101
}

func (r ApiPOSTTasksIdTimeEntriesJsonRequest) Body(body InlineObject101) ApiPOSTTasksIdTimeEntriesJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTTasksIdTimeEntriesJsonRequest) Execute() (InlineResponse20018, *_nethttp.Response, error) {
	return r.ApiService.POSTTasksIdTimeEntriesJsonExecute(r)
}

/*
 * POSTTasksIdTimeEntriesJson Create a Time-Entry (for a Task)
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPOSTTasksIdTimeEntriesJsonRequest
 */
func (a *TimeTrackingApiService) POSTTasksIdTimeEntriesJson(ctx _context.Context, id string) ApiPOSTTasksIdTimeEntriesJsonRequest {
	return ApiPOSTTasksIdTimeEntriesJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20018
 */
func (a *TimeTrackingApiService) POSTTasksIdTimeEntriesJsonExecute(r ApiPOSTTasksIdTimeEntriesJsonRequest) (InlineResponse20018, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20018
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.POSTTasksIdTimeEntriesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}/time_entries.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTTasksIdEstimatedtimeJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
	body *InlineObject97
}

func (r ApiPUTTasksIdEstimatedtimeJsonRequest) Body(body InlineObject97) ApiPUTTasksIdEstimatedtimeJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTTasksIdEstimatedtimeJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.PUTTasksIdEstimatedtimeJsonExecute(r)
}

/*
 * PUTTasksIdEstimatedtimeJson Add a Time estimate to a Task
 * You can add time Estimates to Tasks.
taskEstimatedMinutes must be expressed in minutes.

<h4>Please Note:</h4>
You can also pass in project-id to move this time log to another project.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPUTTasksIdEstimatedtimeJsonRequest
 */
func (a *TimeTrackingApiService) PUTTasksIdEstimatedtimeJson(ctx _context.Context, id string) ApiPUTTasksIdEstimatedtimeJsonRequest {
	return ApiPUTTasksIdEstimatedtimeJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *TimeTrackingApiService) PUTTasksIdEstimatedtimeJsonExecute(r ApiPUTTasksIdEstimatedtimeJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.PUTTasksIdEstimatedtimeJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}/estimatedtime.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTTimeEntriesIdJsonRequest struct {
	ctx _context.Context
	ApiService *TimeTrackingApiService
	id string
	body *InlineObject105
}

func (r ApiPUTTimeEntriesIdJsonRequest) Body(body InlineObject105) ApiPUTTimeEntriesIdJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTTimeEntriesIdJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.PUTTimeEntriesIdJsonExecute(r)
}

/*
 * PUTTimeEntriesIdJson Update a Time Entry
 * Updates the given time-entry record with the data given.

<H4>Please Note:</h4>
You can also pass in project-id to move this time log to another project.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPUTTimeEntriesIdJsonRequest
 */
func (a *TimeTrackingApiService) PUTTimeEntriesIdJson(ctx _context.Context, id string) ApiPUTTimeEntriesIdJsonRequest {
	return ApiPUTTimeEntriesIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *TimeTrackingApiService) PUTTimeEntriesIdJsonExecute(r ApiPUTTimeEntriesIdJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeTrackingApiService.PUTTimeEntriesIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/time_entries/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
