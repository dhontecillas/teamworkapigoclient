/*
 * Teamwork Projects API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pmv1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// TasksApiService TasksApi service
type TasksApiService service

type ApiDELETETasksIdJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
	body *InlineObject96
}

func (r ApiDELETETasksIdJsonRequest) Body(body InlineObject96) ApiDELETETasksIdJsonRequest {
	r.body = &body
	return r
}

func (r ApiDELETETasksIdJsonRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.DELETETasksIdJsonExecute(r)
}

/*
 * DELETETasksIdJson Delete a Task
 * Delete a task using the task id.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiDELETETasksIdJsonRequest
 */
func (a *TasksApiService) DELETETasksIdJson(ctx _context.Context, id string) ApiDELETETasksIdJsonRequest {
	return ApiDELETETasksIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *TasksApiService) DELETETasksIdJsonExecute(r ApiDELETETasksIdJsonRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.DELETETasksIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETCompletedtasksJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	page *int32
	pageSize *int32
	startdate *string
	enddate *string
	includeArchivedProjects *bool
}

func (r ApiGETCompletedtasksJsonRequest) Page(page int32) ApiGETCompletedtasksJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETCompletedtasksJsonRequest) PageSize(pageSize int32) ApiGETCompletedtasksJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETCompletedtasksJsonRequest) Startdate(startdate string) ApiGETCompletedtasksJsonRequest {
	r.startdate = &startdate
	return r
}
func (r ApiGETCompletedtasksJsonRequest) Enddate(enddate string) ApiGETCompletedtasksJsonRequest {
	r.enddate = &enddate
	return r
}
func (r ApiGETCompletedtasksJsonRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETCompletedtasksJsonRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}

func (r ApiGETCompletedtasksJsonRequest) Execute() (InlineResponse20015, *_nethttp.Response, error) {
	return r.ApiService.GETCompletedtasksJsonExecute(r)
}

/*
 * GETCompletedtasksJson Get completed Tasks
 * Retrieve completed Tasks in the last 1 month. You can use the statedate and enddate to go further back in time.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETCompletedtasksJsonRequest
 */
func (a *TasksApiService) GETCompletedtasksJson(ctx _context.Context) ApiGETCompletedtasksJsonRequest {
	return ApiGETCompletedtasksJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20015
 */
func (a *TasksApiService) GETCompletedtasksJsonExecute(r ApiGETCompletedtasksJsonRequest) (InlineResponse20015, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20015
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.GETCompletedtasksJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/completedtasks.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.startdate != nil {
		localVarQueryParams.Add("startdate", parameterToString(*r.startdate, ""))
	}
	if r.enddate != nil {
		localVarQueryParams.Add("enddate", parameterToString(*r.enddate, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETProjectsIdTasksJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
	filter *string
	page *int32
	pageSize *int32
	startDate *string
	endDate *string
	updatedAfterDate *string
	completedAfterDate *string
	completedBeforeDate *string
	showDeleted *string
	includeCompletedTasks *bool
	includeCompletedSubtasks *bool
	creatorIds *string
	include *string
	responsiblePartyIds *string
	sort *string
	getSubTasks *string
	nestSubTasks *string
	getFiles *bool
	includeToday *bool
	ignoreStartDates *bool
	tagIds *string
	dateupdatedASC *string
}

func (r ApiGETProjectsIdTasksJsonRequest) Filter(filter string) ApiGETProjectsIdTasksJsonRequest {
	r.filter = &filter
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) Page(page int32) ApiGETProjectsIdTasksJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) PageSize(pageSize int32) ApiGETProjectsIdTasksJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) StartDate(startDate string) ApiGETProjectsIdTasksJsonRequest {
	r.startDate = &startDate
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) EndDate(endDate string) ApiGETProjectsIdTasksJsonRequest {
	r.endDate = &endDate
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) UpdatedAfterDate(updatedAfterDate string) ApiGETProjectsIdTasksJsonRequest {
	r.updatedAfterDate = &updatedAfterDate
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) CompletedAfterDate(completedAfterDate string) ApiGETProjectsIdTasksJsonRequest {
	r.completedAfterDate = &completedAfterDate
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) CompletedBeforeDate(completedBeforeDate string) ApiGETProjectsIdTasksJsonRequest {
	r.completedBeforeDate = &completedBeforeDate
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) ShowDeleted(showDeleted string) ApiGETProjectsIdTasksJsonRequest {
	r.showDeleted = &showDeleted
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) IncludeCompletedTasks(includeCompletedTasks bool) ApiGETProjectsIdTasksJsonRequest {
	r.includeCompletedTasks = &includeCompletedTasks
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) IncludeCompletedSubtasks(includeCompletedSubtasks bool) ApiGETProjectsIdTasksJsonRequest {
	r.includeCompletedSubtasks = &includeCompletedSubtasks
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) CreatorIds(creatorIds string) ApiGETProjectsIdTasksJsonRequest {
	r.creatorIds = &creatorIds
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) Include(include string) ApiGETProjectsIdTasksJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) ResponsiblePartyIds(responsiblePartyIds string) ApiGETProjectsIdTasksJsonRequest {
	r.responsiblePartyIds = &responsiblePartyIds
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) Sort(sort string) ApiGETProjectsIdTasksJsonRequest {
	r.sort = &sort
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) GetSubTasks(getSubTasks string) ApiGETProjectsIdTasksJsonRequest {
	r.getSubTasks = &getSubTasks
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) NestSubTasks(nestSubTasks string) ApiGETProjectsIdTasksJsonRequest {
	r.nestSubTasks = &nestSubTasks
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) GetFiles(getFiles bool) ApiGETProjectsIdTasksJsonRequest {
	r.getFiles = &getFiles
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) IncludeToday(includeToday bool) ApiGETProjectsIdTasksJsonRequest {
	r.includeToday = &includeToday
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) IgnoreStartDates(ignoreStartDates bool) ApiGETProjectsIdTasksJsonRequest {
	r.ignoreStartDates = &ignoreStartDates
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) TagIds(tagIds string) ApiGETProjectsIdTasksJsonRequest {
	r.tagIds = &tagIds
	return r
}
func (r ApiGETProjectsIdTasksJsonRequest) DateupdatedASC(dateupdatedASC string) ApiGETProjectsIdTasksJsonRequest {
	r.dateupdatedASC = &dateupdatedASC
	return r
}

func (r ApiGETProjectsIdTasksJsonRequest) Execute() (InlineResponse20077, *_nethttp.Response, error) {
	return r.ApiService.GETProjectsIdTasksJsonExecute(r)
}

/*
 * GETProjectsIdTasksJson Get all Tasks on a given Project
 * <h4>Additional notes:</h4>

- responsible-party-ids is only returned if the task is assigned to one or more people. If it is not returned then the task is considered assigned to Anyone.

- DLM is a time stamp and stands for Date Last Modified. We use this internally for our caching system to make sure we can return data to the API calls quickly. Its not guaranteed to be in the response and can be safely ignored if you see it.
- Status is the current status of the task and could be one of the following: deleted, completed, reopened, new
- Private will return a 0, 1 or 2. An open task will be '0', A private task will be '1' and a task which is in a private list will be a '2' as it will inherit the privacy from the parent task list (or parent task)
- A flag canEdit is returned with each task.
-- This call uses pagination. 250 tasks per page.
---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETProjectsIdTasksJsonRequest
 */
func (a *TasksApiService) GETProjectsIdTasksJson(ctx _context.Context, id string) ApiGETProjectsIdTasksJsonRequest {
	return ApiGETProjectsIdTasksJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20077
 */
func (a *TasksApiService) GETProjectsIdTasksJsonExecute(r ApiGETProjectsIdTasksJsonRequest) (InlineResponse20077, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20077
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.GETProjectsIdTasksJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{id}/tasks.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.updatedAfterDate != nil {
		localVarQueryParams.Add("updatedAfterDate", parameterToString(*r.updatedAfterDate, ""))
	}
	if r.completedAfterDate != nil {
		localVarQueryParams.Add("completedAfterDate", parameterToString(*r.completedAfterDate, ""))
	}
	if r.completedBeforeDate != nil {
		localVarQueryParams.Add("completedBeforeDate", parameterToString(*r.completedBeforeDate, ""))
	}
	if r.showDeleted != nil {
		localVarQueryParams.Add("showDeleted", parameterToString(*r.showDeleted, ""))
	}
	if r.includeCompletedTasks != nil {
		localVarQueryParams.Add("includeCompletedTasks", parameterToString(*r.includeCompletedTasks, ""))
	}
	if r.includeCompletedSubtasks != nil {
		localVarQueryParams.Add("includeCompletedSubtasks", parameterToString(*r.includeCompletedSubtasks, ""))
	}
	if r.creatorIds != nil {
		localVarQueryParams.Add("creator-ids", parameterToString(*r.creatorIds, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, ""))
	}
	if r.responsiblePartyIds != nil {
		localVarQueryParams.Add("responsible-party-ids", parameterToString(*r.responsiblePartyIds, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.getSubTasks != nil {
		localVarQueryParams.Add("getSubTasks", parameterToString(*r.getSubTasks, ""))
	}
	if r.nestSubTasks != nil {
		localVarQueryParams.Add("nestSubTasks", parameterToString(*r.nestSubTasks, ""))
	}
	if r.getFiles != nil {
		localVarQueryParams.Add("getFiles", parameterToString(*r.getFiles, ""))
	}
	if r.includeToday != nil {
		localVarQueryParams.Add("includeToday", parameterToString(*r.includeToday, ""))
	}
	if r.ignoreStartDates != nil {
		localVarQueryParams.Add("ignore-start-dates", parameterToString(*r.ignoreStartDates, ""))
	}
	if r.tagIds != nil {
		localVarQueryParams.Add("tag-ids", parameterToString(*r.tagIds, ""))
	}
	if r.dateupdatedASC != nil {
		localVarQueryParams.Add("dateupdatedASC", parameterToString(*r.dateupdatedASC, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasklistsIdTasksJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
	filter *string
	page *int32
	pageSize *int32
	startDate *string
	endDate *string
	updatedAfterDate *string
	completedAfterDate *string
	completedBeforeDate *string
	showDeleted *string
	includeCompletedTasks *bool
	includeCompletedSubtasks *bool
	creatorIds *string
	include *string
	responsiblePartyIds *string
	sort *string
	getSubTasks *string
	nestSubTasks *string
	getFiles *bool
	includeToday *bool
	ignoreStartDates *bool
	tagIds *string
	dateupdatedASC *string
}

func (r ApiGETTasklistsIdTasksJsonRequest) Filter(filter string) ApiGETTasklistsIdTasksJsonRequest {
	r.filter = &filter
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) Page(page int32) ApiGETTasklistsIdTasksJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) PageSize(pageSize int32) ApiGETTasklistsIdTasksJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) StartDate(startDate string) ApiGETTasklistsIdTasksJsonRequest {
	r.startDate = &startDate
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) EndDate(endDate string) ApiGETTasklistsIdTasksJsonRequest {
	r.endDate = &endDate
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) UpdatedAfterDate(updatedAfterDate string) ApiGETTasklistsIdTasksJsonRequest {
	r.updatedAfterDate = &updatedAfterDate
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) CompletedAfterDate(completedAfterDate string) ApiGETTasklistsIdTasksJsonRequest {
	r.completedAfterDate = &completedAfterDate
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) CompletedBeforeDate(completedBeforeDate string) ApiGETTasklistsIdTasksJsonRequest {
	r.completedBeforeDate = &completedBeforeDate
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) ShowDeleted(showDeleted string) ApiGETTasklistsIdTasksJsonRequest {
	r.showDeleted = &showDeleted
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) IncludeCompletedTasks(includeCompletedTasks bool) ApiGETTasklistsIdTasksJsonRequest {
	r.includeCompletedTasks = &includeCompletedTasks
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) IncludeCompletedSubtasks(includeCompletedSubtasks bool) ApiGETTasklistsIdTasksJsonRequest {
	r.includeCompletedSubtasks = &includeCompletedSubtasks
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) CreatorIds(creatorIds string) ApiGETTasklistsIdTasksJsonRequest {
	r.creatorIds = &creatorIds
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) Include(include string) ApiGETTasklistsIdTasksJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) ResponsiblePartyIds(responsiblePartyIds string) ApiGETTasklistsIdTasksJsonRequest {
	r.responsiblePartyIds = &responsiblePartyIds
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) Sort(sort string) ApiGETTasklistsIdTasksJsonRequest {
	r.sort = &sort
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) GetSubTasks(getSubTasks string) ApiGETTasklistsIdTasksJsonRequest {
	r.getSubTasks = &getSubTasks
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) NestSubTasks(nestSubTasks string) ApiGETTasklistsIdTasksJsonRequest {
	r.nestSubTasks = &nestSubTasks
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) GetFiles(getFiles bool) ApiGETTasklistsIdTasksJsonRequest {
	r.getFiles = &getFiles
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) IncludeToday(includeToday bool) ApiGETTasklistsIdTasksJsonRequest {
	r.includeToday = &includeToday
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) IgnoreStartDates(ignoreStartDates bool) ApiGETTasklistsIdTasksJsonRequest {
	r.ignoreStartDates = &ignoreStartDates
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) TagIds(tagIds string) ApiGETTasklistsIdTasksJsonRequest {
	r.tagIds = &tagIds
	return r
}
func (r ApiGETTasklistsIdTasksJsonRequest) DateupdatedASC(dateupdatedASC string) ApiGETTasklistsIdTasksJsonRequest {
	r.dateupdatedASC = &dateupdatedASC
	return r
}

func (r ApiGETTasklistsIdTasksJsonRequest) Execute() (InlineResponse20097, *_nethttp.Response, error) {
	return r.ApiService.GETTasklistsIdTasksJsonExecute(r)
}

/*
 * GETTasklistsIdTasksJson Get all Tasks on a given Task List
 * <h4>Additional notes:</h4>

- responsible-party-ids is only returned if the task is assigned to one or more people. If it is not returned then the task is considered assigned to Anyone.

- DLM is a time stamp and stands for Date Last Modified. We use this internally for our caching system to make sure we can return data to the API calls quickly. Its not guaranteed to be in the response and can be safely ignored if you see it.
- Status is the current status of the task and could be one of the following: deleted, completed, reopened, new
- Private will return a 0, 1 or 2. An open task will be '0', A private task will be '1' and a task which is in a private list will be a '2' as it will inherit the privacy from the parent task list (or parent task)
- A flag canEdit is returned with each task.
- This call uses pagination. 250 tasks per page.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETTasklistsIdTasksJsonRequest
 */
func (a *TasksApiService) GETTasklistsIdTasksJson(ctx _context.Context, id string) ApiGETTasklistsIdTasksJsonRequest {
	return ApiGETTasklistsIdTasksJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20097
 */
func (a *TasksApiService) GETTasklistsIdTasksJsonExecute(r ApiGETTasklistsIdTasksJsonRequest) (InlineResponse20097, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20097
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.GETTasklistsIdTasksJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasklists/{id}/tasks.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.updatedAfterDate != nil {
		localVarQueryParams.Add("updatedAfterDate", parameterToString(*r.updatedAfterDate, ""))
	}
	if r.completedAfterDate != nil {
		localVarQueryParams.Add("completedAfterDate", parameterToString(*r.completedAfterDate, ""))
	}
	if r.completedBeforeDate != nil {
		localVarQueryParams.Add("completedBeforeDate", parameterToString(*r.completedBeforeDate, ""))
	}
	if r.showDeleted != nil {
		localVarQueryParams.Add("showDeleted", parameterToString(*r.showDeleted, ""))
	}
	if r.includeCompletedTasks != nil {
		localVarQueryParams.Add("includeCompletedTasks", parameterToString(*r.includeCompletedTasks, ""))
	}
	if r.includeCompletedSubtasks != nil {
		localVarQueryParams.Add("includeCompletedSubtasks", parameterToString(*r.includeCompletedSubtasks, ""))
	}
	if r.creatorIds != nil {
		localVarQueryParams.Add("creator-ids", parameterToString(*r.creatorIds, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, ""))
	}
	if r.responsiblePartyIds != nil {
		localVarQueryParams.Add("responsible-party-ids", parameterToString(*r.responsiblePartyIds, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.getSubTasks != nil {
		localVarQueryParams.Add("getSubTasks", parameterToString(*r.getSubTasks, ""))
	}
	if r.nestSubTasks != nil {
		localVarQueryParams.Add("nestSubTasks", parameterToString(*r.nestSubTasks, ""))
	}
	if r.getFiles != nil {
		localVarQueryParams.Add("getFiles", parameterToString(*r.getFiles, ""))
	}
	if r.includeToday != nil {
		localVarQueryParams.Add("includeToday", parameterToString(*r.includeToday, ""))
	}
	if r.ignoreStartDates != nil {
		localVarQueryParams.Add("ignore-start-dates", parameterToString(*r.ignoreStartDates, ""))
	}
	if r.tagIds != nil {
		localVarQueryParams.Add("tag-ids", parameterToString(*r.tagIds, ""))
	}
	if r.dateupdatedASC != nil {
		localVarQueryParams.Add("dateupdatedASC", parameterToString(*r.dateupdatedASC, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasksIdDependenciesJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
}


func (r ApiGETTasksIdDependenciesJsonRequest) Execute() (InlineResponse200102, *_nethttp.Response, error) {
	return r.ApiService.GETTasksIdDependenciesJsonExecute(r)
}

/*
 * GETTasksIdDependenciesJson Retrieve Task Dependencies
 * This will list any other Tasks that rely on this task to be completed first.


---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETTasksIdDependenciesJsonRequest
 */
func (a *TasksApiService) GETTasksIdDependenciesJson(ctx _context.Context, id string) ApiGETTasksIdDependenciesJsonRequest {
	return ApiGETTasksIdDependenciesJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200102
 */
func (a *TasksApiService) GETTasksIdDependenciesJsonExecute(r ApiGETTasksIdDependenciesJsonRequest) (InlineResponse200102, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200102
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.GETTasksIdDependenciesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}/dependencies.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasksIdFollowersJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
	returnUserInfo *bool
}

func (r ApiGETTasksIdFollowersJsonRequest) ReturnUserInfo(returnUserInfo bool) ApiGETTasksIdFollowersJsonRequest {
	r.returnUserInfo = &returnUserInfo
	return r
}

func (r ApiGETTasksIdFollowersJsonRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GETTasksIdFollowersJsonExecute(r)
}

/*
 * GETTasksIdFollowersJson Get Task Followers
 * To get a list of users that are following the activity of a given task.

Response including 'returnUserInfo=true' will return the followers infromation:
```json
{
    "followers": [
        {
            "avatarUrl": "https://path/to/person.jpg",
            "firstName": "Joe",
            "companyName": "My Company",
            "followingChanges": true,
            "followingComments": true,
            "id": "12345",
            "companyId": "1",
            "lastName": "Bloggs"
        }
    ],
    "STATUS": "OK"
}
```

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETTasksIdFollowersJsonRequest
 */
func (a *TasksApiService) GETTasksIdFollowersJson(ctx _context.Context, id string) ApiGETTasksIdFollowersJsonRequest {
	return ApiGETTasksIdFollowersJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *TasksApiService) GETTasksIdFollowersJsonExecute(r ApiGETTasksIdFollowersJsonRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.GETTasksIdFollowersJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}/followers.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.returnUserInfo != nil {
		localVarQueryParams.Add("returnUserInfo", parameterToString(*r.returnUserInfo, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasksIdJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
	getFiles *bool
	nestSubTasks *bool
	includeCompletedSubtasks *bool
}

func (r ApiGETTasksIdJsonRequest) GetFiles(getFiles bool) ApiGETTasksIdJsonRequest {
	r.getFiles = &getFiles
	return r
}
func (r ApiGETTasksIdJsonRequest) NestSubTasks(nestSubTasks bool) ApiGETTasksIdJsonRequest {
	r.nestSubTasks = &nestSubTasks
	return r
}
func (r ApiGETTasksIdJsonRequest) IncludeCompletedSubtasks(includeCompletedSubtasks bool) ApiGETTasksIdJsonRequest {
	r.includeCompletedSubtasks = &includeCompletedSubtasks
	return r
}

func (r ApiGETTasksIdJsonRequest) Execute() (InlineResponse200100, *_nethttp.Response, error) {
	return r.ApiService.GETTasksIdJsonExecute(r)
}

/*
 * GETTasksIdJson Retrieve a Task
 * <h4>Additional notes:</h4>

- responsible-party-ids is only returned if the task is assigned to one or more people. If it is not returned then the task is considered assigned to Anyone.

-  Private will return a 0, 1 or 2. An open task will be '0', A private task will be '1' and a task which is in a private list will be a '2' as it will inherit the privacy from the parent task list (or parent task)
-  If a Task is already completed, the following fields will also be visible:
 
    - "status":"completed",
    -  "completed":true,
    - "completed_on":"2017-04-20T12:50:19Z"
---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETTasksIdJsonRequest
 */
func (a *TasksApiService) GETTasksIdJson(ctx _context.Context, id string) ApiGETTasksIdJsonRequest {
	return ApiGETTasksIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200100
 */
func (a *TasksApiService) GETTasksIdJsonExecute(r ApiGETTasksIdJsonRequest) (InlineResponse200100, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200100
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.GETTasksIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.getFiles != nil {
		localVarQueryParams.Add("getFiles", parameterToString(*r.getFiles, ""))
	}
	if r.nestSubTasks != nil {
		localVarQueryParams.Add("nestSubTasks", parameterToString(*r.nestSubTasks, ""))
	}
	if r.includeCompletedSubtasks != nil {
		localVarQueryParams.Add("includeCompletedSubtasks", parameterToString(*r.includeCompletedSubtasks, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasksIdPredecessorsJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
}


func (r ApiGETTasksIdPredecessorsJsonRequest) Execute() (InlineResponse200104, *_nethttp.Response, error) {
	return r.ApiService.GETTasksIdPredecessorsJsonExecute(r)
}

/*
 * GETTasksIdPredecessorsJson Get Task Predecessors
 * A task which has predecessors cannot be completed unless they are first, so they are essentially blocking a task.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiGETTasksIdPredecessorsJsonRequest
 */
func (a *TasksApiService) GETTasksIdPredecessorsJson(ctx _context.Context, id string) ApiGETTasksIdPredecessorsJsonRequest {
	return ApiGETTasksIdPredecessorsJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200104
 */
func (a *TasksApiService) GETTasksIdPredecessorsJsonExecute(r ApiGETTasksIdPredecessorsJsonRequest) (InlineResponse200104, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200104
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.GETTasksIdPredecessorsJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}/predecessors.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasksJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	filter *string
	page *int32
	pageSize *int32
	startDate *string
	endDate *string
	updatedAfterDate *string
	completedAfterDate *string
	completedBeforeDate *string
	showDeleted *string
	includeCompletedTasks *bool
	includeCompletedSubtasks *bool
	creatorIds *string
	include *string
	responsiblePartyIds *string
	sort *string
	getSubTasks *string
	nestSubTasks *string
	getFiles *bool
	includeToday *bool
	ignoreStartDates *bool
	tagIds *string
	includeTasksWithoutDueDates *bool
	includeTasksFromDeletedLists *bool
	includeArchivedProjects *bool
	dateupdatedASC *string
}

func (r ApiGETTasksJsonRequest) Filter(filter string) ApiGETTasksJsonRequest {
	r.filter = &filter
	return r
}
func (r ApiGETTasksJsonRequest) Page(page int32) ApiGETTasksJsonRequest {
	r.page = &page
	return r
}
func (r ApiGETTasksJsonRequest) PageSize(pageSize int32) ApiGETTasksJsonRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiGETTasksJsonRequest) StartDate(startDate string) ApiGETTasksJsonRequest {
	r.startDate = &startDate
	return r
}
func (r ApiGETTasksJsonRequest) EndDate(endDate string) ApiGETTasksJsonRequest {
	r.endDate = &endDate
	return r
}
func (r ApiGETTasksJsonRequest) UpdatedAfterDate(updatedAfterDate string) ApiGETTasksJsonRequest {
	r.updatedAfterDate = &updatedAfterDate
	return r
}
func (r ApiGETTasksJsonRequest) CompletedAfterDate(completedAfterDate string) ApiGETTasksJsonRequest {
	r.completedAfterDate = &completedAfterDate
	return r
}
func (r ApiGETTasksJsonRequest) CompletedBeforeDate(completedBeforeDate string) ApiGETTasksJsonRequest {
	r.completedBeforeDate = &completedBeforeDate
	return r
}
func (r ApiGETTasksJsonRequest) ShowDeleted(showDeleted string) ApiGETTasksJsonRequest {
	r.showDeleted = &showDeleted
	return r
}
func (r ApiGETTasksJsonRequest) IncludeCompletedTasks(includeCompletedTasks bool) ApiGETTasksJsonRequest {
	r.includeCompletedTasks = &includeCompletedTasks
	return r
}
func (r ApiGETTasksJsonRequest) IncludeCompletedSubtasks(includeCompletedSubtasks bool) ApiGETTasksJsonRequest {
	r.includeCompletedSubtasks = &includeCompletedSubtasks
	return r
}
func (r ApiGETTasksJsonRequest) CreatorIds(creatorIds string) ApiGETTasksJsonRequest {
	r.creatorIds = &creatorIds
	return r
}
func (r ApiGETTasksJsonRequest) Include(include string) ApiGETTasksJsonRequest {
	r.include = &include
	return r
}
func (r ApiGETTasksJsonRequest) ResponsiblePartyIds(responsiblePartyIds string) ApiGETTasksJsonRequest {
	r.responsiblePartyIds = &responsiblePartyIds
	return r
}
func (r ApiGETTasksJsonRequest) Sort(sort string) ApiGETTasksJsonRequest {
	r.sort = &sort
	return r
}
func (r ApiGETTasksJsonRequest) GetSubTasks(getSubTasks string) ApiGETTasksJsonRequest {
	r.getSubTasks = &getSubTasks
	return r
}
func (r ApiGETTasksJsonRequest) NestSubTasks(nestSubTasks string) ApiGETTasksJsonRequest {
	r.nestSubTasks = &nestSubTasks
	return r
}
func (r ApiGETTasksJsonRequest) GetFiles(getFiles bool) ApiGETTasksJsonRequest {
	r.getFiles = &getFiles
	return r
}
func (r ApiGETTasksJsonRequest) IncludeToday(includeToday bool) ApiGETTasksJsonRequest {
	r.includeToday = &includeToday
	return r
}
func (r ApiGETTasksJsonRequest) IgnoreStartDates(ignoreStartDates bool) ApiGETTasksJsonRequest {
	r.ignoreStartDates = &ignoreStartDates
	return r
}
func (r ApiGETTasksJsonRequest) TagIds(tagIds string) ApiGETTasksJsonRequest {
	r.tagIds = &tagIds
	return r
}
func (r ApiGETTasksJsonRequest) IncludeTasksWithoutDueDates(includeTasksWithoutDueDates bool) ApiGETTasksJsonRequest {
	r.includeTasksWithoutDueDates = &includeTasksWithoutDueDates
	return r
}
func (r ApiGETTasksJsonRequest) IncludeTasksFromDeletedLists(includeTasksFromDeletedLists bool) ApiGETTasksJsonRequest {
	r.includeTasksFromDeletedLists = &includeTasksFromDeletedLists
	return r
}
func (r ApiGETTasksJsonRequest) IncludeArchivedProjects(includeArchivedProjects bool) ApiGETTasksJsonRequest {
	r.includeArchivedProjects = &includeArchivedProjects
	return r
}
func (r ApiGETTasksJsonRequest) DateupdatedASC(dateupdatedASC string) ApiGETTasksJsonRequest {
	r.dateupdatedASC = &dateupdatedASC
	return r
}

func (r ApiGETTasksJsonRequest) Execute() (InlineResponse20099, *_nethttp.Response, error) {
	return r.ApiService.GETTasksJsonExecute(r)
}

/*
 * GETTasksJson Get all Tasks across all Projects
 * <h4>Additional notes:</h4>

- responsible-party-ids is only returned if the task is assigned to one or more people. If it is not returned then the task is considered assigned to Anyone.

- DLM is a time stamp and stands for Date Last Modified. We use this internally for our caching system to make sure we can return data to the API calls quickly. Its not guaranteed to be in the response and can be safely ignored if you see it.
- Status is the current status of the task and could be one of the following: deleted, completed, reopened, new
- Private will return a 0, 1 or 2. An open task will be '0', A private task will be '1' and a task which is in a private list will be a '2' as it will inherit the privacy from the parent task list (or parent task)
- Dependencies on tasks can either be 0 for none, 1 for yes but task can be started, and 2 for task is blocked by a dependency.
- A flag canEdit is returned with each task.
- Please note: if you delete a task list, the tasks will not be returned in this call.
- This call uses pagination. 250 tasks per page. 
---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGETTasksJsonRequest
 */
func (a *TasksApiService) GETTasksJson(ctx _context.Context) ApiGETTasksJsonRequest {
	return ApiGETTasksJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20099
 */
func (a *TasksApiService) GETTasksJsonExecute(r ApiGETTasksJsonRequest) (InlineResponse20099, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20099
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.GETTasksJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.updatedAfterDate != nil {
		localVarQueryParams.Add("updatedAfterDate", parameterToString(*r.updatedAfterDate, ""))
	}
	if r.completedAfterDate != nil {
		localVarQueryParams.Add("completedAfterDate", parameterToString(*r.completedAfterDate, ""))
	}
	if r.completedBeforeDate != nil {
		localVarQueryParams.Add("completedBeforeDate", parameterToString(*r.completedBeforeDate, ""))
	}
	if r.showDeleted != nil {
		localVarQueryParams.Add("showDeleted", parameterToString(*r.showDeleted, ""))
	}
	if r.includeCompletedTasks != nil {
		localVarQueryParams.Add("includeCompletedTasks", parameterToString(*r.includeCompletedTasks, ""))
	}
	if r.includeCompletedSubtasks != nil {
		localVarQueryParams.Add("includeCompletedSubtasks", parameterToString(*r.includeCompletedSubtasks, ""))
	}
	if r.creatorIds != nil {
		localVarQueryParams.Add("creator-ids", parameterToString(*r.creatorIds, ""))
	}
	if r.include != nil {
		localVarQueryParams.Add("include", parameterToString(*r.include, ""))
	}
	if r.responsiblePartyIds != nil {
		localVarQueryParams.Add("responsible-party-ids", parameterToString(*r.responsiblePartyIds, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.getSubTasks != nil {
		localVarQueryParams.Add("getSubTasks", parameterToString(*r.getSubTasks, ""))
	}
	if r.nestSubTasks != nil {
		localVarQueryParams.Add("nestSubTasks", parameterToString(*r.nestSubTasks, ""))
	}
	if r.getFiles != nil {
		localVarQueryParams.Add("getFiles", parameterToString(*r.getFiles, ""))
	}
	if r.includeToday != nil {
		localVarQueryParams.Add("includeToday", parameterToString(*r.includeToday, ""))
	}
	if r.ignoreStartDates != nil {
		localVarQueryParams.Add("ignore-start-dates", parameterToString(*r.ignoreStartDates, ""))
	}
	if r.tagIds != nil {
		localVarQueryParams.Add("tag-ids", parameterToString(*r.tagIds, ""))
	}
	if r.includeTasksWithoutDueDates != nil {
		localVarQueryParams.Add("includeTasksWithoutDueDates", parameterToString(*r.includeTasksWithoutDueDates, ""))
	}
	if r.includeTasksFromDeletedLists != nil {
		localVarQueryParams.Add("includeTasksFromDeletedLists", parameterToString(*r.includeTasksFromDeletedLists, ""))
	}
	if r.includeArchivedProjects != nil {
		localVarQueryParams.Add("includeArchivedProjects", parameterToString(*r.includeArchivedProjects, ""))
	}
	if r.dateupdatedASC != nil {
		localVarQueryParams.Add("dateupdatedASC", parameterToString(*r.dateupdatedASC, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasksParentTaskIdSubtasksJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	parentTaskId string
}


func (r ApiGETTasksParentTaskIdSubtasksJsonRequest) Execute() (InlineResponse200108, *_nethttp.Response, error) {
	return r.ApiService.GETTasksParentTaskIdSubtasksJsonExecute(r)
}

/*
 * GETTasksParentTaskIdSubtasksJson Get Sub Tasks of a Task
 * Use this endpoint to get the sub tasks of a task.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param parentTaskId
 * @return ApiGETTasksParentTaskIdSubtasksJsonRequest
 */
func (a *TasksApiService) GETTasksParentTaskIdSubtasksJson(ctx _context.Context, parentTaskId string) ApiGETTasksParentTaskIdSubtasksJsonRequest {
	return ApiGETTasksParentTaskIdSubtasksJsonRequest{
		ApiService: a,
		ctx: ctx,
		parentTaskId: parentTaskId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200108
 */
func (a *TasksApiService) GETTasksParentTaskIdSubtasksJsonExecute(r ApiGETTasksParentTaskIdSubtasksJsonRequest) (InlineResponse200108, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200108
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.GETTasksParentTaskIdSubtasksJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{parentTaskId}/subtasks.json"
	localVarPath = strings.Replace(localVarPath, "{"+"parentTaskId"+"}", _neturl.PathEscape(parameterToString(r.parentTaskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGETTasksTaskIdRecurringJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	taskId string
	onlyFutureDates *bool
}

func (r ApiGETTasksTaskIdRecurringJsonRequest) OnlyFutureDates(onlyFutureDates bool) ApiGETTasksTaskIdRecurringJsonRequest {
	r.onlyFutureDates = &onlyFutureDates
	return r
}

func (r ApiGETTasksTaskIdRecurringJsonRequest) Execute() (InlineResponse200110, *_nethttp.Response, error) {
	return r.ApiService.GETTasksTaskIdRecurringJsonExecute(r)
}

/*
 * GETTasksTaskIdRecurringJson Get Recurring Tasks related to original Task.
 * Returns all recurring tasks created and associated with the original task. 

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @return ApiGETTasksTaskIdRecurringJsonRequest
 */
func (a *TasksApiService) GETTasksTaskIdRecurringJson(ctx _context.Context, taskId string) ApiGETTasksTaskIdRecurringJsonRequest {
	return ApiGETTasksTaskIdRecurringJsonRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200110
 */
func (a *TasksApiService) GETTasksTaskIdRecurringJsonExecute(r ApiGETTasksTaskIdRecurringJsonRequest) (InlineResponse200110, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200110
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.GETTasksTaskIdRecurringJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{taskId}/recurring.json"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", _neturl.PathEscape(parameterToString(r.taskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.onlyFutureDates != nil {
		localVarQueryParams.Add("onlyFutureDates", parameterToString(*r.onlyFutureDates, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTProjectsProjIdTasksJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	projId string
	body *InlineObject77
}

func (r ApiPOSTProjectsProjIdTasksJsonRequest) Body(body InlineObject77) ApiPOSTProjectsProjIdTasksJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTProjectsProjIdTasksJsonRequest) Execute() (InlineResponse2016, *_nethttp.Response, error) {
	return r.ApiService.POSTProjectsProjIdTasksJsonExecute(r)
}

/*
 * POSTProjectsProjIdTasksJson Create a Task on a Project
 * This endpoint allows you to create tasks on a project without passing in a specific task list. It will create a task in an 'Inbox' task list. 

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projId
 * @return ApiPOSTProjectsProjIdTasksJsonRequest
 */
func (a *TasksApiService) POSTProjectsProjIdTasksJson(ctx _context.Context, projId string) ApiPOSTProjectsProjIdTasksJsonRequest {
	return ApiPOSTProjectsProjIdTasksJsonRequest{
		ApiService: a,
		ctx: ctx,
		projId: projId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2016
 */
func (a *TasksApiService) POSTProjectsProjIdTasksJsonExecute(r ApiPOSTProjectsProjIdTasksJsonRequest) (InlineResponse2016, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2016
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.POSTProjectsProjIdTasksJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{projId}/tasks.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projId"+"}", _neturl.PathEscape(parameterToString(r.projId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTProjectsProjidTasksQuickaddJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	projid string
	body *InlineObject81
}

func (r ApiPOSTProjectsProjidTasksQuickaddJsonRequest) Body(body InlineObject81) ApiPOSTProjectsProjidTasksQuickaddJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTProjectsProjidTasksQuickaddJsonRequest) Execute() (InlineResponse2017, *_nethttp.Response, error) {
	return r.ApiService.POSTProjectsProjidTasksQuickaddJsonExecute(r)
}

/*
 * POSTProjectsProjidTasksQuickaddJson Quickly add multiple Tasks
 * This allows you to add several tasks to a task list in a single API call.

Quickly adding a task(s) to a task list.

Using "\n" or "~|~" between your task names inside the content parameter will seperate your tasks. This means you can add one or more tasks using this endpoint at the same time.  

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projid
 * @return ApiPOSTProjectsProjidTasksQuickaddJsonRequest
 */
func (a *TasksApiService) POSTProjectsProjidTasksQuickaddJson(ctx _context.Context, projid string) ApiPOSTProjectsProjidTasksQuickaddJsonRequest {
	return ApiPOSTProjectsProjidTasksQuickaddJsonRequest{
		ApiService: a,
		ctx: ctx,
		projid: projid,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2017
 */
func (a *TasksApiService) POSTProjectsProjidTasksQuickaddJsonExecute(r ApiPOSTProjectsProjidTasksQuickaddJsonRequest) (InlineResponse2017, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2017
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.POSTProjectsProjidTasksQuickaddJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{projid}/tasks/quickadd.json"
	localVarPath = strings.Replace(localVarPath, "{"+"projid"+"}", _neturl.PathEscape(parameterToString(r.projid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTTasklistsIdTasksJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
	body *InlineObject91
}

func (r ApiPOSTTasklistsIdTasksJsonRequest) Body(body InlineObject91) ApiPOSTTasklistsIdTasksJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTTasklistsIdTasksJsonRequest) Execute() (InlineResponse201, *_nethttp.Response, error) {
	return r.ApiService.POSTTasklistsIdTasksJsonExecute(r)
}

/*
 * POSTTasklistsIdTasksJson Create a Task
 * For the specified task list, creates a task.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPOSTTasklistsIdTasksJsonRequest
 */
func (a *TasksApiService) POSTTasklistsIdTasksJson(ctx _context.Context, id string) ApiPOSTTasklistsIdTasksJsonRequest {
	return ApiPOSTTasklistsIdTasksJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse201
 */
func (a *TasksApiService) POSTTasklistsIdTasksJsonExecute(r ApiPOSTTasklistsIdTasksJsonRequest) (InlineResponse201, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse201
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.POSTTasklistsIdTasksJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasklists/{id}/tasks.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTTasksIdJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
	body *InlineObject95
}

func (r ApiPOSTTasksIdJsonRequest) Body(body InlineObject95) ApiPOSTTasksIdJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTTasksIdJsonRequest) Execute() (InlineResponse20018, *_nethttp.Response, error) {
	return r.ApiService.POSTTasksIdJsonExecute(r)
}

/*
 * POSTTasksIdJson Create a Sub Task
 * For the specified task, creates a sub task.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPOSTTasksIdJsonRequest
 */
func (a *TasksApiService) POSTTasksIdJson(ctx _context.Context, id string) ApiPOSTTasksIdJsonRequest {
	return ApiPOSTTasksIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20018
 */
func (a *TasksApiService) POSTTasksIdJsonExecute(r ApiPOSTTasksIdJsonRequest) (InlineResponse20018, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20018
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.POSTTasksIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPOSTTasksIdQuickaddJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
	body *InlineObject99
}

func (r ApiPOSTTasksIdQuickaddJsonRequest) Body(body InlineObject99) ApiPOSTTasksIdQuickaddJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTTasksIdQuickaddJsonRequest) Execute() (InlineResponse2017, *_nethttp.Response, error) {
	return r.ApiService.POSTTasksIdQuickaddJsonExecute(r)
}

/*
 * POSTTasksIdQuickaddJson Quickly add multiple Sub Tasks
 * Quickly adding a sub task(s) to a task.

Using "\n" or "~|~" between your task names inside the content parameter will seperate your tasks. This means you can add one or more subtasks using this endpoint at the same time.  

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPOSTTasksIdQuickaddJsonRequest
 */
func (a *TasksApiService) POSTTasksIdQuickaddJson(ctx _context.Context, id string) ApiPOSTTasksIdQuickaddJsonRequest {
	return ApiPOSTTasksIdQuickaddJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2017
 */
func (a *TasksApiService) POSTTasksIdQuickaddJsonExecute(r ApiPOSTTasksIdQuickaddJsonRequest) (InlineResponse2017, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2017
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.POSTTasksIdQuickaddJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}/quickadd.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTTasklistsIdTasksReorderJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
	body *InlineObject92
}

func (r ApiPUTTasklistsIdTasksReorderJsonRequest) Body(body InlineObject92) ApiPUTTasklistsIdTasksReorderJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTTasklistsIdTasksReorderJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.PUTTasklistsIdTasksReorderJsonExecute(r)
}

/*
 * PUTTasklistsIdTasksReorderJson Reorder the Tasks
 * Re-orders tasks on the specified task list. Completed tasks cannot be reordered and any tasks not specified will be sorted after the tasks explicitly specified.

NOTE:
Reordering tasks will move the tasks you are sending to go to the top of the list.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPUTTasklistsIdTasksReorderJsonRequest
 */
func (a *TasksApiService) PUTTasklistsIdTasksReorderJson(ctx _context.Context, id string) ApiPUTTasklistsIdTasksReorderJsonRequest {
	return ApiPUTTasklistsIdTasksReorderJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *TasksApiService) PUTTasklistsIdTasksReorderJsonExecute(r ApiPUTTasklistsIdTasksReorderJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.PUTTasklistsIdTasksReorderJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasklists/{id}/tasks/reorder.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTTasksIdCompleteJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
}


func (r ApiPUTTasksIdCompleteJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.PUTTasksIdCompleteJsonExecute(r)
}

/*
 * PUTTasksIdCompleteJson Mark a Task complete
 * The specified task is marked as complete.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPUTTasksIdCompleteJsonRequest
 */
func (a *TasksApiService) PUTTasksIdCompleteJson(ctx _context.Context, id string) ApiPUTTasksIdCompleteJsonRequest {
	return ApiPUTTasksIdCompleteJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *TasksApiService) PUTTasksIdCompleteJsonExecute(r ApiPUTTasksIdCompleteJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.PUTTasksIdCompleteJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}/complete.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTTasksIdJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
	body *InlineObject94
}

func (r ApiPUTTasksIdJsonRequest) Body(body InlineObject94) ApiPUTTasksIdJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTTasksIdJsonRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PUTTasksIdJsonExecute(r)
}

/*
 * PUTTasksIdJson Update a Task
 * Updates an existing task. See the list of options from "Add a task".

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPUTTasksIdJsonRequest
 */
func (a *TasksApiService) PUTTasksIdJson(ctx _context.Context, id string) ApiPUTTasksIdJsonRequest {
	return ApiPUTTasksIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *TasksApiService) PUTTasksIdJsonExecute(r ApiPUTTasksIdJsonRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.PUTTasksIdJson")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPUTTasksIdUncompleteJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	id string
}


func (r ApiPUTTasksIdUncompleteJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.PUTTasksIdUncompleteJsonExecute(r)
}

/*
 * PUTTasksIdUncompleteJson Mark a Task uncomplete
 * ---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPUTTasksIdUncompleteJsonRequest
 */
func (a *TasksApiService) PUTTasksIdUncompleteJson(ctx _context.Context, id string) ApiPUTTasksIdUncompleteJsonRequest {
	return ApiPUTTasksIdUncompleteJsonRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *TasksApiService) PUTTasksIdUncompleteJsonExecute(r ApiPUTTasksIdUncompleteJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.PUTTasksIdUncompleteJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{id}/uncomplete.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTTasksTaskIdCopyJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	taskId string
	body *InlineObject103
}

func (r ApiPUTTasksTaskIdCopyJsonRequest) Body(body InlineObject103) ApiPUTTasksTaskIdCopyJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTTasksTaskIdCopyJsonRequest) Execute() (InlineResponse200109, *_nethttp.Response, error) {
	return r.ApiService.PUTTasksTaskIdCopyJsonExecute(r)
}

/*
 * PUTTasksTaskIdCopyJson Copy a Task from one Project to Another
 * Copy a task from one project to another by passing in the new project and task list you want to copy it over to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @return ApiPUTTasksTaskIdCopyJsonRequest
 */
func (a *TasksApiService) PUTTasksTaskIdCopyJson(ctx _context.Context, taskId string) ApiPUTTasksTaskIdCopyJsonRequest {
	return ApiPUTTasksTaskIdCopyJsonRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200109
 */
func (a *TasksApiService) PUTTasksTaskIdCopyJsonExecute(r ApiPUTTasksTaskIdCopyJsonRequest) (InlineResponse200109, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200109
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.PUTTasksTaskIdCopyJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{taskId}/copy.json"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", _neturl.PathEscape(parameterToString(r.taskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTTasksTaskIdJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	taskId string
	body *InlineObject102
}

func (r ApiPUTTasksTaskIdJsonRequest) Body(body InlineObject102) ApiPUTTasksTaskIdJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTTasksTaskIdJsonRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.PUTTasksTaskIdJsonExecute(r)
}

/*
 * PUTTasksTaskIdJson Editing Task Predecessors
 * <b>If the task already has predecessors you need to also include them in this call or they will be removed.</b>

This means, every time you do a PUT call and include the predecessor field in the body of the request, you need to pass in all current predecessors and any new ones you want to add. If you want to remove a predecessor you need to remove it from the field and it will be deleted.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @return ApiPUTTasksTaskIdJsonRequest
 */
func (a *TasksApiService) PUTTasksTaskIdJson(ctx _context.Context, taskId string) ApiPUTTasksTaskIdJsonRequest {
	return ApiPUTTasksTaskIdJsonRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *TasksApiService) PUTTasksTaskIdJsonExecute(r ApiPUTTasksTaskIdJsonRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.PUTTasksTaskIdJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{taskId}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", _neturl.PathEscape(parameterToString(r.taskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTTasksTaskIdMoveJsonRequest struct {
	ctx _context.Context
	ApiService *TasksApiService
	taskId string
	body *InlineObject104
}

func (r ApiPUTTasksTaskIdMoveJsonRequest) Body(body InlineObject104) ApiPUTTasksTaskIdMoveJsonRequest {
	r.body = &body
	return r
}

func (r ApiPUTTasksTaskIdMoveJsonRequest) Execute() (InlineResponse200109, *_nethttp.Response, error) {
	return r.ApiService.PUTTasksTaskIdMoveJsonExecute(r)
}

/*
 * PUTTasksTaskIdMoveJson Move a Task from one Project to Another
 * Move a task from one project to another by passing in the new project and task list you want to move it to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @return ApiPUTTasksTaskIdMoveJsonRequest
 */
func (a *TasksApiService) PUTTasksTaskIdMoveJson(ctx _context.Context, taskId string) ApiPUTTasksTaskIdMoveJsonRequest {
	return ApiPUTTasksTaskIdMoveJsonRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200109
 */
func (a *TasksApiService) PUTTasksTaskIdMoveJsonExecute(r ApiPUTTasksTaskIdMoveJsonRequest) (InlineResponse200109, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200109
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TasksApiService.PUTTasksTaskIdMoveJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{taskId}/move.json"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", _neturl.PathEscape(parameterToString(r.taskId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
