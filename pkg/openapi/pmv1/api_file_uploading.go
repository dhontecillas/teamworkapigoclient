/*
 * Teamwork Projects API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pmv1

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// FileUploadingApiService FileUploadingApi service
type FileUploadingApiService service

type ApiPOSTPendingfilesJsonRequest struct {
	ctx _context.Context
	ApiService *FileUploadingApiService
	body *InlineObject36
}

func (r ApiPOSTPendingfilesJsonRequest) Body(body InlineObject36) ApiPOSTPendingfilesJsonRequest {
	r.body = &body
	return r
}

func (r ApiPOSTPendingfilesJsonRequest) Execute() (InlineResponse2011, *_nethttp.Response, error) {
	return r.ApiService.POSTPendingfilesJsonExecute(r)
}

/*
 * POSTPendingfilesJson Upload a File (Classic)
 * Send your file to POST /pendingfiles.json using the FORM field file.
You will still need to authenticate yourself by passing your API token.
If the upload is successful, you will get back a ref ID to pass into another call.

---
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPOSTPendingfilesJsonRequest
 */
func (a *FileUploadingApiService) POSTPendingfilesJson(ctx _context.Context) ApiPOSTPendingfilesJsonRequest {
	return ApiPOSTPendingfilesJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2011
 */
func (a *FileUploadingApiService) POSTPendingfilesJsonExecute(r ApiPOSTPendingfilesJsonRequest) (InlineResponse2011, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2011
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileUploadingApiService.POSTPendingfilesJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pendingfiles.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPUTProjectsApiV1PendingfilesPresignedurlJsonRequest struct {
	ctx _context.Context
	ApiService *FileUploadingApiService
}


func (r ApiPUTProjectsApiV1PendingfilesPresignedurlJsonRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.PUTProjectsApiV1PendingfilesPresignedurlJsonExecute(r)
}

/*
 * PUTProjectsApiV1PendingfilesPresignedurlJson File Upload (Preferred)
 * <h3>File uploading with the API is a 3 step process:</h3>

---

1. **Generate the link:** Send a GET request to the presigned URL with the file details:
 - fileName
 - fileSize
 
This will return a ref ID and  a URL for uploading.

**Endpoint:**
http://YOURSITE/projects/api/v1/pendingfiles/presignedurl.json?fileName=test.txt&fileSize=1024

**Response:**
```
{
  "ref": "tf_...",
  "url": "https://tw-bucket.s3.amazonaws.com/tf_...?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=...&X-Amz-Date=20190413T083843Z&X-Amz-Expires=600&X-Amz-Security-Token=...&X-Amz-SignedHeaders=content-length%3Bhost%3Bx-amz-acl&X-Amz-Signature=..."
}
```

2. **Upload the file**: Send a PUT request to the link above, with the 'file' in the body of the request. Along with this, you need the following hearders:
- X-Amz-Acl: public-read
- Content-Length: file-size
- Host: host-from-the-generate-link

**Coding Example**
```
curl -v -i -X PUT --data-binary "@test.txt" --header "X-Amz-Acl: public-read" --header "Host: tw-bucket.s3.amazonaws.com" --header "Content-Length: 1024" https://tw-bucket.s3.amazonaws.com/...
```

**If successful you should get a 200 response.** 

3.**Finalize the file upload:**
You can now use the ref ID from the first GET request to attach it to an object eg. task.

To attach to a task:
PUT: /tasks/ID.json

```
{
  "todo-item": {
    "pendingFileAttachments": "tf_..."
  }
}
```
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPUTProjectsApiV1PendingfilesPresignedurlJsonRequest
 */
func (a *FileUploadingApiService) PUTProjectsApiV1PendingfilesPresignedurlJson(ctx _context.Context) ApiPUTProjectsApiV1PendingfilesPresignedurlJsonRequest {
	return ApiPUTProjectsApiV1PendingfilesPresignedurlJsonRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *FileUploadingApiService) PUTProjectsApiV1PendingfilesPresignedurlJsonExecute(r ApiPUTProjectsApiV1PendingfilesPresignedurlJsonRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FileUploadingApiService.PUTProjectsApiV1PendingfilesPresignedurlJson")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/api/v1/pendingfiles/presignedurl.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
